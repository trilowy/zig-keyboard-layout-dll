//! Translation of a C file Bepolar keyboard layout generated by MSKLC

const std = @import("std");

// TODO: make all types const?
// TODO: add all comment doc
// TODO: other TODO

// Windows types: https://learn.microsoft.com/en-us/windows/win32/learnwin32/windows-coding-conventions
const WORD = c_ushort;
const DWORD = c_ulong;
const WCHAR = c_ushort; // 16-bit UNICODE character
const USHORT = c_ushort;
const BYTE = u8;
// TODO: const DWORD_PTR = usize;
// TODO: const LONG = c_long;

const L = std.unicode.utf8ToUtf16LeStringLiteral;

const KBD_TYPE = 4;

// Virtual Keys, Standard Set
const VK_LBUTTON = 0x01;
const VK_RBUTTON = 0x02;
const VK_CANCEL = 0x03;
const VK_MBUTTON = 0x04; // NOT contiguous with L & RBUTTON

// #if(_WIN32_WINNT >= 0x0500)
const VK_XBUTTON1 = 0x05; // NOT contiguous with L & RBUTTON
const VK_XBUTTON2 = 0x06; // NOT contiguous with L & RBUTTON
// #endif

// 0x07 : unassigned

const VK_BACK = 0x08;
const VK_TAB = 0x09;

// 0x0A - 0x0B : reserved

const VK_CLEAR = 0x0C;
const VK_RETURN = 0x0D;

const VK_SHIFT = 0x10;
const VK_CONTROL = 0x11;
const VK_MENU = 0x12;
const VK_PAUSE = 0x13;
const VK_CAPITAL = 0x14;

const VK_KANA = 0x15;
const VK_HANGEUL = 0x15; // old name - should be here for compatibility
const VK_HANGUL = 0x15;
const VK_JUNJA = 0x17;
const VK_FINAL = 0x18;
const VK_HANJA = 0x19;
const VK_KANJI = 0x19;

const VK_ESCAPE = 0x1B;

const VK_CONVERT = 0x1C;
const VK_NONCONVERT = 0x1D;
const VK_ACCEPT = 0x1E;
const VK_MODECHANGE = 0x1F;

const VK_SPACE = 0x20;
const VK_PRIOR = 0x21;
const VK_NEXT = 0x22;
const VK_END = 0x23;
const VK_HOME = 0x24;
const VK_LEFT = 0x25;
const VK_UP = 0x26;
const VK_RIGHT = 0x27;
const VK_DOWN = 0x28;
const VK_SELECT = 0x29;
const VK_PRINT = 0x2A;
const VK_EXECUTE = 0x2B;
const VK_SNAPSHOT = 0x2C;
const VK_INSERT = 0x2D;
const VK_DELETE = 0x2E;
const VK_HELP = 0x2F;

// VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
// 0x40 : unassigned
// VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)

const VK_LWIN = 0x5B;
const VK_RWIN = 0x5C;
const VK_APPS = 0x5D;

// 0x5E : reserved

const VK_SLEEP = 0x5F;

const VK_NUMPAD0 = 0x60;
const VK_NUMPAD1 = 0x61;
const VK_NUMPAD2 = 0x62;
const VK_NUMPAD3 = 0x63;
const VK_NUMPAD4 = 0x64;
const VK_NUMPAD5 = 0x65;
const VK_NUMPAD6 = 0x66;
const VK_NUMPAD7 = 0x67;
const VK_NUMPAD8 = 0x68;
const VK_NUMPAD9 = 0x69;
const VK_MULTIPLY = 0x6A;
const VK_ADD = 0x6B;
const VK_SEPARATOR = 0x6C;
const VK_SUBTRACT = 0x6D;
const VK_DECIMAL = 0x6E;
const VK_DIVIDE = 0x6F;
const VK_F1 = 0x70;
const VK_F2 = 0x71;
const VK_F3 = 0x72;
const VK_F4 = 0x73;
const VK_F5 = 0x74;
const VK_F6 = 0x75;
const VK_F7 = 0x76;
const VK_F8 = 0x77;
const VK_F9 = 0x78;
const VK_F10 = 0x79;
const VK_F11 = 0x7A;
const VK_F12 = 0x7B;
const VK_F13 = 0x7C;
const VK_F14 = 0x7D;
const VK_F15 = 0x7E;
const VK_F16 = 0x7F;
const VK_F17 = 0x80;
const VK_F18 = 0x81;
const VK_F19 = 0x82;
const VK_F20 = 0x83;
const VK_F21 = 0x84;
const VK_F22 = 0x85;
const VK_F23 = 0x86;
const VK_F24 = 0x87;

// 0x88 - 0x8F : unassigned

const VK_NUMLOCK = 0x90;
const VK_SCROLL = 0x91;

// NEC PC-9800 kbd definitions
const VK_OEM_NEC_EQUAL = 0x92; // '=' key on numpad

// Fujitsu/OASYS kbd definitions
const VK_OEM_FJ_JISHO = 0x92; // 'Dictionary' key
const VK_OEM_FJ_MASSHOU = 0x93; // 'Unregister word' key
const VK_OEM_FJ_TOUROKU = 0x94; // 'Register word' key
const VK_OEM_FJ_LOYA = 0x95; // 'Left OYAYUBI' key
const VK_OEM_FJ_ROYA = 0x96; // 'Right OYAYUBI' key

// 0x97 - 0x9F : unassigned

// VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
// Used only as parameters to GetAsyncKeyState() and GetKeyState().
// No other API or message will distinguish left and right keys in this way.
const VK_LSHIFT = 0xA0;
const VK_RSHIFT = 0xA1;
const VK_LCONTROL = 0xA2;
const VK_RCONTROL = 0xA3;
const VK_LMENU = 0xA4;
const VK_RMENU = 0xA5;

// #if(_WIN32_WINNT >= 0x0500)
const VK_BROWSER_BACK = 0xA6;
const VK_BROWSER_FORWARD = 0xA7;
const VK_BROWSER_REFRESH = 0xA8;
const VK_BROWSER_STOP = 0xA9;
const VK_BROWSER_SEARCH = 0xAA;
const VK_BROWSER_FAVORITES = 0xAB;
const VK_BROWSER_HOME = 0xAC;

const VK_VOLUME_MUTE = 0xAD;
const VK_VOLUME_DOWN = 0xAE;
const VK_VOLUME_UP = 0xAF;
const VK_MEDIA_NEXT_TRACK = 0xB0;
const VK_MEDIA_PREV_TRACK = 0xB1;
const VK_MEDIA_STOP = 0xB2;
const VK_MEDIA_PLAY_PAUSE = 0xB3;
const VK_LAUNCH_MAIL = 0xB4;
const VK_LAUNCH_MEDIA_SELECT = 0xB5;
const VK_LAUNCH_APP1 = 0xB6;
const VK_LAUNCH_APP2 = 0xB7;
// #endif

// 0xB8 - 0xB9 : reserved

const VK_OEM_1 = 0xBA; // ';:' for US
const VK_OEM_PLUS = 0xBB; // '+' any country
const VK_OEM_COMMA = 0xBC; // ',' any country
const VK_OEM_MINUS = 0xBD; // '-' any country
const VK_OEM_PERIOD = 0xBE; // '.' any country
const VK_OEM_2 = 0xBF; // '/?' for US
const VK_OEM_3 = 0xC0; // '`~' for US

// 0xC1 - 0xD7 : reserved

// 0xD8 - 0xDA : unassigned

const VK_OEM_4 = 0xDB; //  '[{' for US
const VK_OEM_5 = 0xDC; //  '\|' for US
const VK_OEM_6 = 0xDD; //  ']}' for US
const VK_OEM_7 = 0xDE; //  ''"' for US
const VK_OEM_8 = 0xDF;

// 0xE0 : reserved

// Various extended or enhanced keyboards
const VK_OEM_AX = 0xE1; //  'AX' key on Japanese AX kbd
const VK_OEM_102 = 0xE2; //  "<>" or "\|" on RT 102-key kbd.
const VK_ICO_HELP = 0xE3; //  Help key on ICO
const VK_ICO_00 = 0xE4; //  00 key on ICO

// #if(WINVER >= 0x0400)
const VK_PROCESSKEY = 0xE5;
// #endif

const VK_ICO_CLEAR = 0xE6;

// #if(_WIN32_WINNT >= 0x0500)
const VK_PACKET = 0xE7;
// #endif

// 0xE8 : unassigned

// Nokia/Ericsson definitions
const VK_OEM_RESET = 0xE9;
const VK_OEM_JUMP = 0xEA;
const VK_OEM_PA1 = 0xEB;
const VK_OEM_PA2 = 0xEC;
const VK_OEM_PA3 = 0xED;
const VK_OEM_WSCTRL = 0xEE;
const VK_OEM_CUSEL = 0xEF;
const VK_OEM_ATTN = 0xF0;
const VK_OEM_FINISH = 0xF1;
const VK_OEM_COPY = 0xF2;
const VK_OEM_AUTO = 0xF3;
const VK_OEM_ENLW = 0xF4;
const VK_OEM_BACKTAB = 0xF5;

const VK_ATTN = 0xF6;
const VK_CRSEL = 0xF7;
const VK_EXSEL = 0xF8;
const VK_EREOF = 0xF9;
const VK_PLAY = 0xFA;
const VK_ZOOM = 0xFB;
const VK_NONAME = 0xFC;
const VK_PA1 = 0xFD;
const VK_OEM_CLEAR = 0xFE;

// 0xFF : reserved
const VK__none_ = 0xFF;
const VK_ABNT_C1 = 0xC1;
const VK_ABNT_C2 = 0xC2;

// KE.usFlaggedVk values, also used in the keyboard layer tables.
const KBDEXT = 0x0100;
const KBDMULTIVK = 0x0200;
const KBDSPECIAL = 0x0400;
const KBDNUMPAD = 0x0800;
const KBDUNICODE = 0x1000;
const KBDINJECTEDVK = 0x2000;
// #if (NTDDI_VERSION >= NTDDI_WINXP)
const KBDMAPPEDVK = 0x4000;
// #endif
const KBDBREAK = 0x8000;

// Key message lParam bits
const EXTENDED_BIT = 0x01000000;
const DONTCARE_BIT = 0x02000000;
const FAKE_KEYSTROKE = 0x02000000;
const ALTNUMPAD_BIT = 0x04000000; // copied from windows\inc\wincon.w

// Keyboard Shift State defines. These correspond to the bit mask defined
// by the VkKeyScan() API.
const KBDBASE = 0;
const KBDSHIFT = 1;
const KBDCTRL = 2;
const KBDALT = 4;
// three symbols KANA, ROYA, LOYA are for FE
const KBDKANA = 8;
const KBDROYA = 0x10;
const KBDLOYA = 0x20;
const KBDGRPSELTAP = 0x80;

const SHFT_INVALID = 0x0F;

/// No character is generated by pressing this key with the current shift state.
const WCH_NONE = 0xF000;
/// The character is a dead-key: the next VK_TO_WCHARS[] entry
/// will contain the values of the dead characters (diaresis)
/// that can be produced by the Virtual Key.
const WCH_DEAD = 0xF001;

const CAPLOK = 0x01;

// T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
//
// These values are for Scancode Set 3 and the USA.
// Other languages substitute their own values where required (files kbd**.h)
//
// Six sets of keyboards are supported, according to KBD_TYPE:
//
// KBD_TYPE   Keyboard (examples)
// ========   =======================================================
//    1       AT&T '301' & '302'; Olivetti 83-key; PC-XT 84-key; etc.
//    2       Olivetti M24 102-key
//    3       HP Vectra (DIN); Olivetti 86-key; etc.
//    4 *     Enhanced 101/102-key; Olivetti A; etc.
//    5       Nokia (Ericsson) type 5 (1050, etc.)
//    6       Nokia (Ericsson) type 6 (9140)
//
// * If KBD_TYPE is not defined, the default is type 4.
//
// KB3270 comments refers to KB 3270 keyboards in native emulation mode (DIP
// switches all OFF), and the Scancode Map used to convert its scancodes to
// standard scancode set 1.
//    KB3270 <= 57      - this entry is reached by mapping from scancode 0x57
//                        to an arbitrary scancode: the VK is what counts
//    KB3270 => HOME    - this scancode is mapped to the scancode for VK_HOME
//    KB3270            - no mapping involved, a scancode for KB3270 only
//
// _EQ() : all keyboard types have the same virtual key for this scancode
// _NE() : different virtual keys for this scancode, depending on kbd type
//
//     +------+ +--------+--------+--------+--------+--------+--------+
//     | Scan | |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |
//     | code | | type 1 | type 2 | type 3 | type 4 | type 5 | type 6 |
//    +-------+-+--------+--------+--------+--------+--------+--------+

const T00 = _EQ(VK__none_);
const T01 = _EQ(VK_ESCAPE);
const T02 = _EQ('1');
const T03 = _EQ('2');
const T04 = _EQ('3');
const T05 = _EQ('4');
const T06 = _EQ('5');
const T07 = _EQ('6');
const T08 = _EQ('7');
const T09 = _EQ('8');
const T0A = _EQ('9');
const T0B = _EQ('0');
const T0C = _EQ(VK_OEM_MINUS);
const T0D = _NE(VK_OEM_PLUS, VK_OEM_4, VK_OEM_PLUS, VK_OEM_PLUS, VK_OEM_PLUS, VK_OEM_PLUS);
const T0E = _EQ(VK_BACK);
const T0F = _EQ(VK_TAB);
const T10 = _EQ('Q');
const T11 = _EQ('W');
const T12 = _EQ('E');
const T13 = _EQ('R');
const T14 = _EQ('T');
const T15 = _EQ('Y');
const T16 = _EQ('U');
const T17 = _EQ('I');
const T18 = _EQ('O');
const T19 = _EQ('P');
const T1A = _NE(VK_OEM_4, VK_OEM_6, VK_OEM_4, VK_OEM_4, VK_OEM_4, VK_OEM_4);
const T1B = _NE(VK_OEM_6, VK_OEM_1, VK_OEM_6, VK_OEM_6, VK_OEM_6, VK_OEM_6);
const T1C = _EQ(VK_RETURN);
const T1D = _EQ(VK_LCONTROL);
const T1E = _EQ('A');
const T1F = _EQ('S');
const T20 = _EQ('D');
const T21 = _EQ('F');
const T22 = _EQ('G');
const T23 = _EQ('H');
const T24 = _EQ('J');
const T25 = _EQ('K');
const T26 = _EQ('L');
const T27 = _NE(VK_OEM_1, VK_OEM_PLUS, VK_OEM_1, VK_OEM_1, VK_OEM_1, VK_OEM_1);
const T28 = _NE(VK_OEM_7, VK_OEM_3, VK_OEM_7, VK_OEM_7, VK_OEM_3, VK_OEM_3);
const T29 = _NE(VK_OEM_3, VK_OEM_7, VK_OEM_3, VK_OEM_3, VK_OEM_7, VK_OEM_7);
const T2A = _EQ(VK_LSHIFT);
const T2B = _EQ(VK_OEM_5);
const T2C = _EQ('Z');
const T2D = _EQ('X');
const T2E = _EQ('C');
const T2F = _EQ('V');
const T30 = _EQ('B');
const T31 = _EQ('N');
const T32 = _EQ('M');
const T33 = _EQ(VK_OEM_COMMA);
const T34 = _EQ(VK_OEM_PERIOD);
const T35 = _EQ(VK_OEM_2);
const T36 = _EQ(VK_RSHIFT);
const T37 = _EQ(VK_MULTIPLY);
const T38 = _EQ(VK_LMENU);
const T39 = _EQ(' ');
const T3A = _EQ(VK_CAPITAL);
const T3B = _EQ(VK_F1);
const T3C = _EQ(VK_F2);
const T3D = _EQ(VK_F3);
const T3E = _EQ(VK_F4);
const T3F = _EQ(VK_F5);
const T40 = _EQ(VK_F6);
const T41 = _EQ(VK_F7);
const T42 = _EQ(VK_F8);
const T43 = _EQ(VK_F9);
const T44 = _EQ(VK_F10);
const T45 = _EQ(VK_NUMLOCK);
const T46 = _EQ(VK_SCROLL);
const T47 = _EQ(VK_HOME);
const T48 = _EQ(VK_UP);
const T49 = _EQ(VK_PRIOR);
const T4A = _EQ(VK_SUBTRACT);
const T4B = _EQ(VK_LEFT);
const T4C = _EQ(VK_CLEAR);
const T4D = _EQ(VK_RIGHT);
const T4E = _EQ(VK_ADD);
const T4F = _EQ(VK_END);
const T50 = _EQ(VK_DOWN);
const T51 = _EQ(VK_NEXT);
const T52 = _EQ(VK_INSERT);
const T53 = _EQ(VK_DELETE);
const T54 = _EQ(VK_SNAPSHOT);
const T55 = _EQ(VK__none_); // KB3270 => DOWN
const T56 = _NE(VK_OEM_102, VK_HELP, VK_OEM_102, VK_OEM_102, VK__none_, VK_OEM_PA2); // KB3270 => LEFT
const T57 = _NE(VK_F11, VK_RETURN, VK_F11, VK_F11, VK__none_, VK_HELP); // KB3270 => ZOOM
const T58 = _NE(VK_F12, VK_LEFT, VK_F12, VK_F12, VK__none_, VK_OEM_102); // KB3270 => HELP
const T59 = _EQ(VK_CLEAR);
const T5A = _EQ(VK_OEM_WSCTRL); // WSCtrl
const T5B = _EQ(VK_OEM_FINISH); // Finish
const T5C = _EQ(VK_OEM_JUMP); // Jump
const T5D = _EQ(VK_EREOF);
const T5E = _EQ(VK_OEM_BACKTAB); // KB3270 <= 7E
const T5F = _EQ(VK_OEM_AUTO); // KB3270
const T60 = _EQ(VK__none_);
const T61 = _EQ(VK__none_);
const T62 = _EQ(VK_ZOOM); // KB3270 <= 57
const T63 = _EQ(VK_HELP); // KB3270 <= 58
const T64 = _EQ(VK_F13);
const T65 = _EQ(VK_F14);
const T66 = _EQ(VK_F15);
const T67 = _EQ(VK_F16);
const T68 = _EQ(VK_F17);
const T69 = _EQ(VK_F18);
const T6A = _EQ(VK_F19);
const T6B = _EQ(VK_F20);
const T6C = _EQ(VK_F21);
const T6D = _EQ(VK_F22);
const T6E = _EQ(VK_F23);
const T6F = _EQ(VK_OEM_PA3); // KB3270
const T70 = _EQ(VK__none_);
const T71 = _EQ(VK_OEM_RESET); // KB3270
const T72 = _EQ(VK__none_);
const T73 = _EQ(VK_ABNT_C1);
const T74 = _EQ(VK__none_);
const T75 = _EQ(VK__none_); // KB3270 => RETURN
const T76 = _EQ(VK_F24);
const T77 = _EQ(VK__none_); // KB3270 => HOME
const T78 = _EQ(VK__none_); // KB3270 => UP
const T79 = _EQ(VK__none_); // KB3270 => DELETE
const T7A = _EQ(VK__none_); // KB3270 => INSERT
const T7B = _EQ(VK_OEM_PA1); // KB3270
const T7C = _EQ(VK_TAB); // KB3270 => TAB
const T7D = _EQ(VK__none_); // KB3270 => RIGHT
const T7E = _EQ(VK_ABNT_C2); // KB3270 => BACKTAB
const T7F = _EQ(VK_OEM_PA2); // KB3270

const X10 = _EQ(VK_MEDIA_PREV_TRACK); // SpeedRacer
const X19 = _EQ(VK_MEDIA_NEXT_TRACK); // SpeedRacer
const X1C = _EQ(VK_RETURN);
const X1D = _EQ(VK_RCONTROL);
const X20 = _EQ(VK_VOLUME_MUTE); // SpeedRacer
const X21 = _EQ(VK_LAUNCH_APP2); // SpeedRacer (Calculator?)
const X22 = _EQ(VK_MEDIA_PLAY_PAUSE); // SpeedRacer
const X24 = _EQ(VK_MEDIA_STOP); // SpeedRacer
const X2E = _EQ(VK_VOLUME_DOWN); // SpeedRacer
const X30 = _EQ(VK_VOLUME_UP); // SpeedRacer
const X32 = _EQ(VK_BROWSER_HOME); // SpeedRacer
const X35 = _EQ(VK_DIVIDE);
const X37 = _EQ(VK_SNAPSHOT);
const X38 = _EQ(VK_RMENU);
const X46 = _EQ(VK_CANCEL);
const X47 = _EQ(VK_HOME);
const X48 = _EQ(VK_UP);
const X49 = _EQ(VK_PRIOR);
const X4B = _EQ(VK_LEFT);
const X4D = _EQ(VK_RIGHT);
const X4F = _EQ(VK_END);
const X50 = _EQ(VK_DOWN);
const X51 = _NE(VK_NEXT, VK_F1, VK_NEXT, VK_NEXT, VK__none_, VK_OEM_PA2);
const X52 = _EQ(VK_INSERT);
const X53 = _EQ(VK_DELETE);
const X5B = _EQ(VK_LWIN);
const X5C = _EQ(VK_RWIN);
const X5D = _EQ(VK_APPS);
// const X5E = _EQ(VK_POWER); // TODO: I don’t know where POWER is defined
const X5F = _EQ(VK_SLEEP); // SpeedRacer
const X65 = _EQ(VK_BROWSER_SEARCH); // SpeedRacer
const X66 = _EQ(VK_BROWSER_FAVORITES); // SpeedRacer
const X67 = _EQ(VK_BROWSER_REFRESH); // SpeedRacer
const X68 = _EQ(VK_BROWSER_STOP); // SpeedRacer
const X69 = _EQ(VK_BROWSER_FORWARD); // SpeedRacer
const X6A = _EQ(VK_BROWSER_BACK); // SpeedRacer
const X6B = _EQ(VK_LAUNCH_APP1); // SpeedRacer (my computer?)
const X6C = _EQ(VK_LAUNCH_MAIL); // SpeedRacer
const X6D = _EQ(VK_LAUNCH_MEDIA_SELECT); // SpeedRacer

// The break key is sent to us as E1,LCtrl,NumLock
// We must convert the E1+LCtrl to BREAK, then ignore the Numlock
const Y1D = _EQ(VK_PAUSE);

// Along with ligature support we're adding a proper version number.
// The previous version number (actually just unused bits...) was
// always zero. The version number will live in the high word of
// fLocaleFlags.
const KBD_VERSION = 1;

// Attributes such as AltGr, LRM_RLM, ShiftLock are stored in the the low word
// of fLocaleFlags (layout specific) or in gdwKeyboardAttributes (all layouts)
const KLLF_ALTGR = 0x0001;
const KLLF_SHIFTLOCK = 0x0002;
const KLLF_LRM_RLM = 0x0004;

// The DLL entrypoint
pub export fn KbdLayerDescriptor() callconv(.C) *KBDTABLES {
    // Map Virtual Keys to Modifier Bits
    //
    // The keyboard has only three shifter keys:
    //     SHIFT (L & R) affects alphabnumeric keys,
    //     CTRL  (L & R) is used to generate control characters
    //     ALT   (L & R) used for generating characters by number with numpad
    var virtual_keys_to_modifier_bits = [_]VK_TO_BIT{
        VK_TO_BIT{
            .Vk = VK_SHIFT,
            .ModBits = KBDSHIFT,
        },
        VK_TO_BIT{
            .Vk = VK_CONTROL,
            .ModBits = KBDCTRL,
        },
        VK_TO_BIT{
            .Vk = VK_MENU,
            .ModBits = KBDALT,
        },
        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_BIT{
            .Vk = 0,
            .ModBits = 0,
        },
    };

    // Map character modifier bits to modification number
    var mod_number = [_]BYTE{
        //  Modification //  Keys Pressed
        //  ============ // =============
        0, //
        1, // Shift
        2, // Control
        3, // Shift + Control
        SHFT_INVALID, // Menu
        SHFT_INVALID, // Shift + Menu
        4, // Control + Menu
        5, // Shift + Control + Menu
    };

    var modifiers = MODIFIERS{
        .pVkToBit = &virtual_keys_to_modifier_bits,
        .wMaxModBits = 7,
        .ModNumber = &mod_number,
    };

    // VK_TO_WCHARS<n> - Associate a Virtual Key with <n> UNICODE characters
    //
    // VirtualKey  - The Virtual Key.
    // wch[]       - An array of characters, one for each shift state that
    //               applies to the specified Virtual Key.
    //
    // Special values for VirtualKey:
    //    -1        - This entry contains dead chars for the previous entry
    //    0         - Terminates a VK_TO_WCHARS[] table
    //
    // Special values for Attributes:
    //    CAPLOK    - The CAPS-LOCK key affects this key like SHIFT
    //    SGCAPS    - CapsLock uppercases the unshifted char (Swiss-German)
    //
    // Special values for wch[*]:
    //    WCH_NONE  - No character is generated by pressing this key with the
    //                current shift state.
    //    WCH_DEAD  - The character is a dead-key: the next VK_TO_WCHARS[] entry
    //                will contain the values of the dead characters (diaresis)
    //                that can be produced by the Virtual Key.
    //    WCH_LGTR  - The character is a ligature.  The characters generated by
    //                this keystroke are found in the ligature table.

    // vk_to_wchar_2 - Virtual Key to WCHAR translation for 2 shift states
    // vk_to_wchar_3 - Virtual Key to WCHAR translation for 3 shift states
    // vk_to_wchar_4 - Virtual Key to WCHAR translation for 4 shift states
    // vk_to_wchar_5 - Virtual Key to WCHAR translation for 5 shift states
    // vk_to_wchar_6 - Virtual Key to WCHAR translation for 6 shift states
    //
    // Table attributes: Unordered Scan, null-terminated
    //
    // Search this table for an entry with a matching Virtual Key to find the
    // corresponding unshifted and shifted WCHAR characters.
    //
    // Special values for VirtualKey (column 1)
    //     0xff          - dead chars for the previous entry
    //     0             - terminate the list
    //
    // Special values for Attributes (column 2)
    //     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT
    //
    // Special values for wch[*] (column 3 & 4)
    //     WCH_NONE      - No character
    //     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)
    //     WCH_LGTR      - Ligature (generates multiple characters)

    var vk_to_wchar_3 = [_]VK_TO_WCHARS(3){
        //                      |         |  Shift  |  Ctrl   |
        //                      |=========|=========|=========|
        VK_TO_WCHARS(3){ .VirtualKey = VK_BACK, .Attributes = 0, .wch = [_]c_ushort{ 0x08, 0x08, 0x007f } }, // Zig can not escape '\b' for now, see https://github.com/ziglang/zig/issues/21564
        VK_TO_WCHARS(3){ .VirtualKey = VK_ESCAPE, .Attributes = 0, .wch = [_]c_ushort{ 0x001b, 0x001b, 0x001b } },
        VK_TO_WCHARS(3){ .VirtualKey = VK_RETURN, .Attributes = 0, .wch = [_]c_ushort{ '\r', '\r', '\n' } },
        VK_TO_WCHARS(3){ .VirtualKey = VK_CANCEL, .Attributes = 0, .wch = [_]c_ushort{ 0x0003, 0x0003, 0x0003 } },
        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_WCHARS(3){ .VirtualKey = 0, .Attributes = 0, .wch = [_]c_ushort{ 0, 0, 0 } },
    };

    var vk_to_wchar_6 = [_]VK_TO_WCHARS(6){
        //                      |         |  Shift  |  Ctrl   |S+Ctrl   |  Ctl+Alt|S+Ctl+Alt|
        //                      |=========|=========|=========|=========|=========|=========|
        VK_TO_WCHARS(6){ .VirtualKey = '1', .Attributes = 0, .wch = [_]c_ushort{ '1', 0x0023, WCH_NONE, WCH_NONE, 0x2081, 0x00b9 } },
        VK_TO_WCHARS(6){ .VirtualKey = '2', .Attributes = 0, .wch = [_]c_ushort{ '2', 0x00ab, WCH_NONE, WCH_NONE, 0x2082, 0x00b2 } },
        VK_TO_WCHARS(6){ .VirtualKey = '3', .Attributes = 0, .wch = [_]c_ushort{ '3', 0x00bb, WCH_NONE, WCH_NONE, 0x2083, 0x00b3 } },
        VK_TO_WCHARS(6){ .VirtualKey = '4', .Attributes = 0, .wch = [_]c_ushort{ '4', 0x0028, WCH_NONE, WCH_NONE, 0x2084, 0x2074 } },
        VK_TO_WCHARS(6){ .VirtualKey = '5', .Attributes = 0, .wch = [_]c_ushort{ '5', 0x0029, WCH_NONE, WCH_NONE, 0x2085, 0x2075 } },
        VK_TO_WCHARS(6){ .VirtualKey = '6', .Attributes = 0, .wch = [_]c_ushort{ '6', 0x0040, WCH_NONE, WCH_NONE, 0x2086, 0x2076 } },
        VK_TO_WCHARS(6){ .VirtualKey = '7', .Attributes = 0, .wch = [_]c_ushort{ '7', 0x002b, WCH_NONE, WCH_NONE, 0x2087, 0x2077 } },
        VK_TO_WCHARS(6){ .VirtualKey = '8', .Attributes = 0, .wch = [_]c_ushort{ '8', 0x005e, WCH_NONE, WCH_NONE, 0x2088, 0x2078 } },
        VK_TO_WCHARS(6){ .VirtualKey = '9', .Attributes = 0, .wch = [_]c_ushort{ '9', 0x002f, WCH_NONE, WCH_NONE, 0x2089, 0x2079 } },
        VK_TO_WCHARS(6){ .VirtualKey = '0', .Attributes = 0, .wch = [_]c_ushort{ '0', 0x002a, WCH_NONE, WCH_NONE, 0x2080, 0x2070 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'B', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'b', 'B', WCH_NONE, WCH_NONE, 0x005e, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x005e } },
        VK_TO_WCHARS(6){ .VirtualKey = 'M', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'm', 'M', WCH_NONE, WCH_NONE, 0x003c, 0x2264 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'P', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'p', 'P', WCH_NONE, WCH_NONE, 0x003e, 0x2265 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'O', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'o', 'O', WCH_NONE, WCH_NONE, 0x0024, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x00a4 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'W', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'w', 'W', WCH_NONE, WCH_NONE, 0x0025, 0x2030 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'Z', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'z', 'Z', WCH_NONE, WCH_NONE, 0x0040, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x02da } },
        VK_TO_WCHARS(6){ .VirtualKey = 'V', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'v', 'V', WCH_NONE, WCH_NONE, 0x0026, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 'D', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'd', 'D', WCH_NONE, WCH_NONE, 0x002a, 0x00d7 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'L', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'l', 'L', WCH_NONE, WCH_NONE, 0x0027, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x0027 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'J', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'j', 'J', WCH_NONE, WCH_NONE, 0x0060, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x0060 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'A', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'a', 'A', WCH_NONE, WCH_NONE, 0x007b, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x02c7 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'U', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'u', 'U', WCH_NONE, WCH_NONE, 0x0028, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 'I', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'i', 'I', WCH_NONE, WCH_NONE, 0x0029, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 'E', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'e', 'E', WCH_NONE, WCH_NONE, 0x007d, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x02d9 } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_COMMA, .Attributes = 0, .wch = [_]c_ushort{ 0x002c, 0x003b, WCH_NONE, WCH_NONE, 0x003d, 0x2260 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'C', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'c', 'C', WCH_NONE, WCH_NONE, 0x005c, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x002f } },
        VK_TO_WCHARS(6){ .VirtualKey = 'T', .Attributes = CAPLOK, .wch = [_]c_ushort{ 't', 'T', WCH_NONE, WCH_NONE, 0x002b, 0x00b1 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'S', .Attributes = CAPLOK, .wch = [_]c_ushort{ 's', 'S', WCH_NONE, WCH_NONE, 0x002d, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x00af } },
        VK_TO_WCHARS(6){ .VirtualKey = 'R', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'r', 'R', WCH_NONE, WCH_NONE, 0x002f, 0x00f7 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'N', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'n', 'N', WCH_NONE, WCH_NONE, 0x0022, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x201d } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_MINUS, .Attributes = 0, .wch = [_]c_ushort{ 0x002d, 0x0021, WCH_NONE, WCH_NONE, 0x007e, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = 0, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x007e } },
        VK_TO_WCHARS(6){ .VirtualKey = 'Y', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'y', 'Y', WCH_NONE, WCH_NONE, 0x005b, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x002c } },
        VK_TO_WCHARS(6){ .VirtualKey = 'X', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'x', 'X', WCH_NONE, WCH_NONE, 0x005d, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x02db } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_PERIOD, .Attributes = 0, .wch = [_]c_ushort{ 0x002e, 0x003a, WCH_NONE, WCH_NONE, 0x005f, 0x2013 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'K', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'k', 'K', WCH_NONE, WCH_NONE, 0x0023, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_1, .Attributes = 0, .wch = [_]c_ushort{ WCH_DEAD, 0x003f, WCH_NONE, WCH_NONE, 0x007c, 0x00a6 } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = 0, .wch = [_]c_ushort{ 0x2019, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 'Q', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'q', 'Q', WCH_NONE, WCH_NONE, 0x0021, 0x00ac } },
        VK_TO_WCHARS(6){ .VirtualKey = 'G', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'g', 'G', WCH_NONE, WCH_NONE, 0x003b, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x00b8 } },
        VK_TO_WCHARS(6){ .VirtualKey = 'H', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'h', 'H', WCH_NONE, WCH_NONE, 0x003a, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 'F', .Attributes = CAPLOK, .wch = [_]c_ushort{ 'f', 'F', WCH_NONE, WCH_NONE, 0x003f, WCH_DEAD } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = CAPLOK, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x02d8 } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_2, .Attributes = 0, .wch = [_]c_ushort{ 0x003d, WCH_DEAD, WCH_NONE, WCH_NONE, 0x208e, 0x207e } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = 0, .wch = [_]c_ushort{ WCH_NONE, 0x00b5, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_3, .Attributes = 0, .wch = [_]c_ushort{ 0x0025, 0x00a7, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_4, .Attributes = 0, .wch = [_]c_ushort{ 0x005b, 0x007b, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_5, .Attributes = 0, .wch = [_]c_ushort{ 0x005d, 0x007d, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_6, .Attributes = 0, .wch = [_]c_ushort{ 0x0027, 0x0022, WCH_NONE, WCH_NONE, WCH_DEAD, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = 0xff, .Attributes = 0, .wch = [_]c_ushort{ WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE, 0x0027, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_7, .Attributes = 0, .wch = [_]c_ushort{ 0x007e, 0x00ac, WCH_NONE, WCH_NONE, 0x208d, 0x207d } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_8, .Attributes = 0, .wch = [_]c_ushort{ 0x0024, 0x20ac, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_OEM_102, .Attributes = 0, .wch = [_]c_ushort{ 0x002f, 0x005c, WCH_NONE, WCH_NONE, WCH_NONE, WCH_NONE } },
        VK_TO_WCHARS(6){ .VirtualKey = VK_SPACE, .Attributes = 0, .wch = [_]c_ushort{ 0x0020, 0x202f, WCH_NONE, WCH_NONE, 0x0020, 0x00a0 } },
        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_WCHARS(6){ .VirtualKey = 0, .Attributes = 0, .wch = [_]c_ushort{ 0, 0, 0, 0, 0, 0 } },
    };

    var vk_to_wchar_2 = [_]VK_TO_WCHARS(2){
        //                      |         |  Shift  |
        //                      |=========|=========|
        VK_TO_WCHARS(2){ .VirtualKey = VK_TAB, .Attributes = 0, .wch = [_]c_ushort{ '\t', '\t' } },
        VK_TO_WCHARS(2){ .VirtualKey = VK_ADD, .Attributes = 0, .wch = [_]c_ushort{ '+', '+' } },
        VK_TO_WCHARS(2){ .VirtualKey = VK_DIVIDE, .Attributes = 0, .wch = [_]c_ushort{ '/', '/' } },
        VK_TO_WCHARS(2){ .VirtualKey = VK_MULTIPLY, .Attributes = 0, .wch = [_]c_ushort{ '*', '*' } },
        VK_TO_WCHARS(2){ .VirtualKey = VK_SUBTRACT, .Attributes = 0, .wch = [_]c_ushort{ '-', '-' } },
        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_WCHARS(2){ .VirtualKey = 0, .Attributes = 0, .wch = [_]c_ushort{ 0, 0 } },
    };

    // Put this last so that VkKeyScan interprets number characters
    // as coming from the main section of the kbd (vk_to_char_2 and
    // vk_to_char_5) before considering the numpad (vk_to_char_1).
    var vk_to_wchar_1 = [_]VK_TO_WCHARS(1){
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD0, .Attributes = 0, .wch = [_]c_ushort{'0'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD1, .Attributes = 0, .wch = [_]c_ushort{'1'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD2, .Attributes = 0, .wch = [_]c_ushort{'2'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD3, .Attributes = 0, .wch = [_]c_ushort{'3'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD4, .Attributes = 0, .wch = [_]c_ushort{'4'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD5, .Attributes = 0, .wch = [_]c_ushort{'5'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD6, .Attributes = 0, .wch = [_]c_ushort{'6'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD7, .Attributes = 0, .wch = [_]c_ushort{'7'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD8, .Attributes = 0, .wch = [_]c_ushort{'8'} },
        VK_TO_WCHARS(1){ .VirtualKey = VK_NUMPAD9, .Attributes = 0, .wch = [_]c_ushort{'9'} },
        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_WCHARS(1){ .VirtualKey = 0, .Attributes = 0, .wch = [_]c_ushort{0} },
    };

    var vk_to_wchar_table = [_]VK_TO_WCHAR_TABLE{
        VK_TO_WCHAR_TABLE{
            .pVkToWchars = @ptrCast(&vk_to_wchar_3),
            .nModifications = 3,
            .cbSize = @sizeOf(VK_TO_WCHARS(3)),
        },
        VK_TO_WCHAR_TABLE{
            .pVkToWchars = @ptrCast(&vk_to_wchar_6),
            .nModifications = 6,
            .cbSize = @sizeOf(VK_TO_WCHARS(6)),
        },
        VK_TO_WCHAR_TABLE{
            .pVkToWchars = @ptrCast(&vk_to_wchar_2),
            .nModifications = 2,
            .cbSize = @sizeOf(VK_TO_WCHARS(2)),
        },
        VK_TO_WCHAR_TABLE{
            .pVkToWchars = @ptrCast(&vk_to_wchar_1),
            .nModifications = 1,
            .cbSize = @sizeOf(VK_TO_WCHARS(1)),
        },
        // End pointer list with null
        // TODO: see if it must ends by null (sentinel)
        // ziglings 076_sentinels.zig
        VK_TO_WCHAR_TABLE{
            .pVkToWchars = null,
            .nModifications = 0,
            .cbSize = 0,
        },
    };

    var dead_keys = [_]DEADKEY{
        // DEADKEY: 1DK
        DEADTRANS(0x2019, 0x2019, 0x0022, 0x0001), // ’ -> "
        DEADTRANS(0x0031, 0x2019, 0x0026, 0x0000), // 1 -> &
        DEADTRANS(0x00ab, 0x2019, 0x201c, 0x0000), // « -> “
        DEADTRANS(0x0032, 0x2019, 0x003c, 0x0000), // 2 -> <
        DEADTRANS(0x00bb, 0x2019, 0x201d, 0x0000), // » -> ”
        DEADTRANS(0x0033, 0x2019, 0x003e, 0x0000), // 3 -> >
        DEADTRANS(0x0028, 0x2019, 0x201e, 0x0000), // ( -> „
        DEADTRANS(0x0034, 0x2019, 0x0028, 0x0000), // 4 -> (
        DEADTRANS(0x0029, 0x2019, 0x2018, 0x0000), // ) -> ‘
        DEADTRANS(0x0035, 0x2019, 0x0029, 0x0000), // 5 -> )
        DEADTRANS(0x0036, 0x2019, 0x0040, 0x0000), // 6 -> @
        DEADTRANS(0x002b, 0x2019, 0x00f7, 0x0000), // + -> ÷
        DEADTRANS(0x0037, 0x2019, 0x00b1, 0x0000), // 7 -> ±
        DEADTRANS(0x005e, 0x2019, 0x02c7, 0x0001), // ^ -> ˇ
        DEADTRANS(0x0038, 0x2019, 0x005e, 0x0001), // 8 -> ^
        DEADTRANS(0x002f, 0x2019, 0x007c, 0x0000), // / -> |
        DEADTRANS(0x0039, 0x2019, 0x005c, 0x0000), // 9 -> \
        DEADTRANS(0x002a, 0x2019, 0x00d7, 0x0000), // * -> ×
        DEADTRANS(0x0030, 0x2019, 0x00b0, 0x0000), // 0 -> °
        DEADTRANS(0x0042, 0x2019, 0x00c2, 0x0000), // B -> Â
        DEADTRANS(0x0062, 0x2019, 0x00e2, 0x0000), // b -> â
        DEADTRANS(0x004d, 0x2019, 0x00db, 0x0000), // M -> Û
        DEADTRANS(0x006d, 0x2019, 0x00fb, 0x0000), // m -> û
        DEADTRANS(0x0050, 0x2019, 0x00ce, 0x0000), // P -> Î
        DEADTRANS(0x0070, 0x2019, 0x00ee, 0x0000), // p -> î
        DEADTRANS(0x004f, 0x2019, 0x00d4, 0x0000), // O -> Ô
        DEADTRANS(0x006f, 0x2019, 0x00f4, 0x0000), // o -> ô
        DEADTRANS(0x0057, 0x2019, 0x0152, 0x0000), // W -> Œ
        DEADTRANS(0x0077, 0x2019, 0x0153, 0x0000), // w -> œ
        DEADTRANS(0x0056, 0x2019, 0x016c, 0x0000), // V -> Ŭ
        DEADTRANS(0x0076, 0x2019, 0x016d, 0x0000), // v -> ŭ
        DEADTRANS(0x0064, 0x2019, 0x0028, 0x0000), // d -> (
        DEADTRANS(0x006c, 0x2019, 0x0029, 0x0000), // l -> )
        DEADTRANS(0x0041, 0x2019, 0x00c0, 0x0000), // A -> À
        DEADTRANS(0x0061, 0x2019, 0x00e0, 0x0000), // a -> à
        DEADTRANS(0x0055, 0x2019, 0x00d9, 0x0000), // U -> Ù
        DEADTRANS(0x0075, 0x2019, 0x00f9, 0x0000), // u -> ù
        DEADTRANS(0x0049, 0x2019, 0x00c9, 0x0000), // I -> É
        DEADTRANS(0x0069, 0x2019, 0x00e9, 0x0000), // i -> é
        DEADTRANS(0x0045, 0x2019, 0x00c8, 0x0000), // E -> È
        DEADTRANS(0x0065, 0x2019, 0x00e8, 0x0000), // e -> è
        DEADTRANS(0x003b, 0x2019, 0x00ca, 0x0000), // ; -> Ê
        DEADTRANS(0x002c, 0x2019, 0x00ea, 0x0000), // , -> ê
        DEADTRANS(0x0043, 0x2019, 0x00c7, 0x0000), // C -> Ç
        DEADTRANS(0x0063, 0x2019, 0x00e7, 0x0000), // c -> ç
        DEADTRANS(0x0074, 0x2019, 0x2122, 0x0000), // t -> ™
        DEADTRANS(0x0053, 0x2019, 0x1e9e, 0x0000), // S -> ẞ
        DEADTRANS(0x0073, 0x2019, 0x00df, 0x0000), // s -> ß
        DEADTRANS(0x0072, 0x2019, 0x00ae, 0x0000), // r -> ®
        DEADTRANS(0x004e, 0x2019, 0x00d1, 0x0000), // N -> Ñ
        DEADTRANS(0x006e, 0x2019, 0x00f1, 0x0000), // n -> ñ
        DEADTRANS(0x0021, 0x2019, 0x00a1, 0x0000), // ! -> ¡
        DEADTRANS(0x002d, 0x2019, 0x2014, 0x0000), // - -> —
        DEADTRANS(0x0059, 0x2019, 0x0176, 0x0000), // Y -> Ŷ
        DEADTRANS(0x0079, 0x2019, 0x0177, 0x0000), // y -> ŷ
        DEADTRANS(0x0078, 0x2019, 0x005f, 0x0000), // x -> _
        DEADTRANS(0x003a, 0x2019, 0x00b7, 0x0000), // : -> ·
        DEADTRANS(0x002e, 0x2019, 0x2026, 0x0000), // . -> …
        DEADTRANS(0x004b, 0x2019, 0x00c6, 0x0000), // K -> Æ
        DEADTRANS(0x006b, 0x2019, 0x00e6, 0x0000), // k -> æ
        DEADTRANS(0x003f, 0x2019, 0x00bf, 0x0000), // ? -> ¿
        DEADTRANS(0x0071, 0x2019, 0x2013, 0x0000), // q -> –
        DEADTRANS(0x0067, 0x2019, 0x00b5, 0x0000), // g -> µ
        DEADTRANS(0x0068, 0x2019, 0x00a9, 0x0000), // h -> ©
        DEADTRANS(0x0066, 0x2019, 0x2011, 0x0000), // f -> ‑
        DEADTRANS(0x003d, 0x2019, 0x2260, 0x0000), // = -> ≠
        DEADTRANS(0x00a7, 0x2019, 0x00b6, 0x0000), // § -> ¶
        DEADTRANS(0x0025, 0x2019, 0x2030, 0x0000), // % -> ‰
        DEADTRANS(0x0027, 0x2019, 0x0060, 0x0000), // ' -> `
        DEADTRANS(0x007e, 0x2019, 0x007e, 0x0001), // ~ -> ~
        DEADTRANS(0x20ac, 0x2019, 0x00a4, 0x0001), // € -> ¤
        DEADTRANS(0x0024, 0x2019, 0x00a2, 0x0000), // $ -> ¢
        DEADTRANS(0x005c, 0x2019, 0x00a6, 0x0000), // \ -> ¦
        DEADTRANS(0x202f, 0x2019, 0x2019, 0x0000), //   -> ’
        DEADTRANS(0x0020, 0x2019, 0x2019, 0x0000), //   -> ’
        DEADTRANS(0x00a0, 0x2019, 0x2019, 0x0000), //   -> ’

        // DEADKEY: GRAVE
        DEADTRANS(0x0041, 0x0060, 0x00c0, 0x0000), // A -> À
        DEADTRANS(0x0061, 0x0060, 0x00e0, 0x0000), // a -> à
        DEADTRANS(0x0045, 0x0060, 0x00c8, 0x0000), // E -> È
        DEADTRANS(0x0065, 0x0060, 0x00e8, 0x0000), // e -> è
        DEADTRANS(0x0049, 0x0060, 0x00cc, 0x0000), // I -> Ì
        DEADTRANS(0x0069, 0x0060, 0x00ec, 0x0000), // i -> ì
        DEADTRANS(0x004e, 0x0060, 0x01f8, 0x0000), // N -> Ǹ
        DEADTRANS(0x006e, 0x0060, 0x01f9, 0x0000), // n -> ǹ
        DEADTRANS(0x004f, 0x0060, 0x00d2, 0x0000), // O -> Ò
        DEADTRANS(0x006f, 0x0060, 0x00f2, 0x0000), // o -> ò
        DEADTRANS(0x0055, 0x0060, 0x00d9, 0x0000), // U -> Ù
        DEADTRANS(0x0075, 0x0060, 0x00f9, 0x0000), // u -> ù
        DEADTRANS(0x0057, 0x0060, 0x1e80, 0x0000), // W -> Ẁ
        DEADTRANS(0x0077, 0x0060, 0x1e81, 0x0000), // w -> ẁ
        DEADTRANS(0x0059, 0x0060, 0x1ef2, 0x0000), // Y -> Ỳ
        DEADTRANS(0x0079, 0x0060, 0x1ef3, 0x0000), // y -> ỳ
        DEADTRANS(0x0020, 0x0060, 0x0060, 0x0000), //   -> `
        DEADTRANS(0x00a0, 0x0060, 0x0060, 0x0000), //   -> `
        DEADTRANS(0x202f, 0x0060, 0x0060, 0x0000), //   -> `

        // DEADKEY: ACUTE
        DEADTRANS(0x0041, 0x0027, 0x00c1, 0x0000), // A -> Á
        DEADTRANS(0x0061, 0x0027, 0x00e1, 0x0000), // a -> á
        DEADTRANS(0x0043, 0x0027, 0x0106, 0x0000), // C -> Ć
        DEADTRANS(0x0063, 0x0027, 0x0107, 0x0000), // c -> ć
        DEADTRANS(0x0045, 0x0027, 0x00c9, 0x0000), // E -> É
        DEADTRANS(0x0065, 0x0027, 0x00e9, 0x0000), // e -> é
        DEADTRANS(0x0047, 0x0027, 0x01f4, 0x0000), // G -> Ǵ
        DEADTRANS(0x0067, 0x0027, 0x01f5, 0x0000), // g -> ǵ
        DEADTRANS(0x0049, 0x0027, 0x00cd, 0x0000), // I -> Í
        DEADTRANS(0x0069, 0x0027, 0x00ed, 0x0000), // i -> í
        DEADTRANS(0x004b, 0x0027, 0x1e30, 0x0000), // K -> Ḱ
        DEADTRANS(0x006b, 0x0027, 0x1e31, 0x0000), // k -> ḱ
        DEADTRANS(0x004c, 0x0027, 0x0139, 0x0000), // L -> Ĺ
        DEADTRANS(0x006c, 0x0027, 0x013a, 0x0000), // l -> ĺ
        DEADTRANS(0x004d, 0x0027, 0x1e3e, 0x0000), // M -> Ḿ
        DEADTRANS(0x006d, 0x0027, 0x1e3f, 0x0000), // m -> ḿ
        DEADTRANS(0x004e, 0x0027, 0x0143, 0x0000), // N -> Ń
        DEADTRANS(0x006e, 0x0027, 0x0144, 0x0000), // n -> ń
        DEADTRANS(0x004f, 0x0027, 0x00d3, 0x0000), // O -> Ó
        DEADTRANS(0x006f, 0x0027, 0x00f3, 0x0000), // o -> ó
        DEADTRANS(0x0050, 0x0027, 0x1e54, 0x0000), // P -> Ṕ
        DEADTRANS(0x0070, 0x0027, 0x1e55, 0x0000), // p -> ṕ
        DEADTRANS(0x0052, 0x0027, 0x0154, 0x0000), // R -> Ŕ
        DEADTRANS(0x0072, 0x0027, 0x0155, 0x0000), // r -> ŕ
        DEADTRANS(0x0053, 0x0027, 0x015a, 0x0000), // S -> Ś
        DEADTRANS(0x0073, 0x0027, 0x015b, 0x0000), // s -> ś
        DEADTRANS(0x0055, 0x0027, 0x00da, 0x0000), // U -> Ú
        DEADTRANS(0x0075, 0x0027, 0x00fa, 0x0000), // u -> ú
        DEADTRANS(0x0057, 0x0027, 0x1e82, 0x0000), // W -> Ẃ
        DEADTRANS(0x0077, 0x0027, 0x1e83, 0x0000), // w -> ẃ
        DEADTRANS(0x0059, 0x0027, 0x00dd, 0x0000), // Y -> Ý
        DEADTRANS(0x0079, 0x0027, 0x00fd, 0x0000), // y -> ý
        DEADTRANS(0x005a, 0x0027, 0x0179, 0x0000), // Z -> Ź
        DEADTRANS(0x007a, 0x0027, 0x017a, 0x0000), // z -> ź
        DEADTRANS(0x0020, 0x0027, 0x0027, 0x0000), //   -> '
        DEADTRANS(0x00a0, 0x0027, 0x0027, 0x0000), //   -> '
        DEADTRANS(0x202f, 0x0027, 0x0027, 0x0000), //   -> '

        // DEADKEY: DOUBLEACUTE
        DEADTRANS(0x201d, 0x201d, 0x02dd, 0x0000), // ” -> ˝
        DEADTRANS(0x004f, 0x201d, 0x0150, 0x0000), // O -> Ő
        DEADTRANS(0x006f, 0x201d, 0x0151, 0x0000), // o -> ő
        DEADTRANS(0x0055, 0x201d, 0x0170, 0x0000), // U -> Ű
        DEADTRANS(0x0075, 0x201d, 0x0171, 0x0000), // u -> ű
        DEADTRANS(0x0020, 0x201d, 0x201d, 0x0000), //   -> ”
        DEADTRANS(0x00a0, 0x201d, 0x201d, 0x0000), //   -> ”
        DEADTRANS(0x202f, 0x201d, 0x201d, 0x0000), //   -> ”

        // DEADKEY: CIRCUMFLEX
        DEADTRANS(0x0041, 0x005e, 0x00c2, 0x0000), // A -> Â
        DEADTRANS(0x0061, 0x005e, 0x00e2, 0x0000), // a -> â
        DEADTRANS(0x0043, 0x005e, 0x0108, 0x0000), // C -> Ĉ
        DEADTRANS(0x0063, 0x005e, 0x0109, 0x0000), // c -> ĉ
        DEADTRANS(0x0045, 0x005e, 0x00ca, 0x0000), // E -> Ê
        DEADTRANS(0x0065, 0x005e, 0x00ea, 0x0000), // e -> ê
        DEADTRANS(0x0047, 0x005e, 0x011c, 0x0000), // G -> Ĝ
        DEADTRANS(0x0067, 0x005e, 0x011d, 0x0000), // g -> ĝ
        DEADTRANS(0x0048, 0x005e, 0x0124, 0x0000), // H -> Ĥ
        DEADTRANS(0x0068, 0x005e, 0x0125, 0x0000), // h -> ĥ
        DEADTRANS(0x0049, 0x005e, 0x00ce, 0x0000), // I -> Î
        DEADTRANS(0x0069, 0x005e, 0x00ee, 0x0000), // i -> î
        DEADTRANS(0x004a, 0x005e, 0x0134, 0x0000), // J -> Ĵ
        DEADTRANS(0x006a, 0x005e, 0x0135, 0x0000), // j -> ĵ
        DEADTRANS(0x004f, 0x005e, 0x00d4, 0x0000), // O -> Ô
        DEADTRANS(0x006f, 0x005e, 0x00f4, 0x0000), // o -> ô
        DEADTRANS(0x0053, 0x005e, 0x015c, 0x0000), // S -> Ŝ
        DEADTRANS(0x0073, 0x005e, 0x015d, 0x0000), // s -> ŝ
        DEADTRANS(0x0055, 0x005e, 0x00db, 0x0000), // U -> Û
        DEADTRANS(0x0075, 0x005e, 0x00fb, 0x0000), // u -> û
        DEADTRANS(0x0057, 0x005e, 0x0174, 0x0000), // W -> Ŵ
        DEADTRANS(0x0077, 0x005e, 0x0175, 0x0000), // w -> ŵ
        DEADTRANS(0x0059, 0x005e, 0x0176, 0x0000), // Y -> Ŷ
        DEADTRANS(0x0079, 0x005e, 0x0177, 0x0000), // y -> ŷ
        DEADTRANS(0x005a, 0x005e, 0x1e90, 0x0000), // Z -> Ẑ
        DEADTRANS(0x007a, 0x005e, 0x1e91, 0x0000), // z -> ẑ
        DEADTRANS(0x0030, 0x005e, 0x2070, 0x0000), // 0 -> ⁰
        DEADTRANS(0x0031, 0x005e, 0x00b9, 0x0000), // 1 -> ¹
        DEADTRANS(0x0032, 0x005e, 0x00b2, 0x0000), // 2 -> ²
        DEADTRANS(0x0033, 0x005e, 0x00b3, 0x0000), // 3 -> ³
        DEADTRANS(0x0034, 0x005e, 0x2074, 0x0000), // 4 -> ⁴
        DEADTRANS(0x0035, 0x005e, 0x2075, 0x0000), // 5 -> ⁵
        DEADTRANS(0x0036, 0x005e, 0x2076, 0x0000), // 6 -> ⁶
        DEADTRANS(0x0037, 0x005e, 0x2077, 0x0000), // 7 -> ⁷
        DEADTRANS(0x0038, 0x005e, 0x2078, 0x0000), // 8 -> ⁸
        DEADTRANS(0x0039, 0x005e, 0x2079, 0x0000), // 9 -> ⁹
        DEADTRANS(0x0028, 0x005e, 0x207d, 0x0000), // ( -> ⁽
        DEADTRANS(0x0029, 0x005e, 0x207e, 0x0000), // ) -> ⁾
        DEADTRANS(0x002b, 0x005e, 0x207a, 0x0000), // + -> ⁺
        DEADTRANS(0x002d, 0x005e, 0x207b, 0x0000), // - -> ⁻
        DEADTRANS(0x003d, 0x005e, 0x207c, 0x0000), // = -> ⁼
        DEADTRANS(0x0020, 0x005e, 0x005e, 0x0000), //   -> ^
        DEADTRANS(0x00a0, 0x005e, 0x005e, 0x0000), //   -> ^
        DEADTRANS(0x202f, 0x005e, 0x005e, 0x0000), //   -> ^

        // DEADKEY: CARON
        DEADTRANS(0x0041, 0x02c7, 0x01cd, 0x0000), // A -> Ǎ
        DEADTRANS(0x0061, 0x02c7, 0x01ce, 0x0000), // a -> ǎ
        DEADTRANS(0x0043, 0x02c7, 0x010c, 0x0000), // C -> Č
        DEADTRANS(0x0063, 0x02c7, 0x010d, 0x0000), // c -> č
        DEADTRANS(0x0044, 0x02c7, 0x010e, 0x0000), // D -> Ď
        DEADTRANS(0x0064, 0x02c7, 0x010f, 0x0000), // d -> ď
        DEADTRANS(0x0045, 0x02c7, 0x011a, 0x0000), // E -> Ě
        DEADTRANS(0x0065, 0x02c7, 0x011b, 0x0000), // e -> ě
        DEADTRANS(0x0047, 0x02c7, 0x01e6, 0x0000), // G -> Ǧ
        DEADTRANS(0x0067, 0x02c7, 0x01e7, 0x0000), // g -> ǧ
        DEADTRANS(0x0048, 0x02c7, 0x021e, 0x0000), // H -> Ȟ
        DEADTRANS(0x0068, 0x02c7, 0x021f, 0x0000), // h -> ȟ
        DEADTRANS(0x0049, 0x02c7, 0x01cf, 0x0000), // I -> Ǐ
        DEADTRANS(0x0069, 0x02c7, 0x01d0, 0x0000), // i -> ǐ
        DEADTRANS(0x004b, 0x02c7, 0x01e8, 0x0000), // K -> Ǩ
        DEADTRANS(0x006b, 0x02c7, 0x01e9, 0x0000), // k -> ǩ
        DEADTRANS(0x004c, 0x02c7, 0x013d, 0x0000), // L -> Ľ
        DEADTRANS(0x006c, 0x02c7, 0x013e, 0x0000), // l -> ľ
        DEADTRANS(0x004e, 0x02c7, 0x0147, 0x0000), // N -> Ň
        DEADTRANS(0x006e, 0x02c7, 0x0148, 0x0000), // n -> ň
        DEADTRANS(0x004f, 0x02c7, 0x01d1, 0x0000), // O -> Ǒ
        DEADTRANS(0x006f, 0x02c7, 0x01d2, 0x0000), // o -> ǒ
        DEADTRANS(0x0052, 0x02c7, 0x0158, 0x0000), // R -> Ř
        DEADTRANS(0x0072, 0x02c7, 0x0159, 0x0000), // r -> ř
        DEADTRANS(0x0053, 0x02c7, 0x0160, 0x0000), // S -> Š
        DEADTRANS(0x0073, 0x02c7, 0x0161, 0x0000), // s -> š
        DEADTRANS(0x0054, 0x02c7, 0x0164, 0x0000), // T -> Ť
        DEADTRANS(0x0074, 0x02c7, 0x0165, 0x0000), // t -> ť
        DEADTRANS(0x0055, 0x02c7, 0x01d3, 0x0000), // U -> Ǔ
        DEADTRANS(0x0075, 0x02c7, 0x01d4, 0x0000), // u -> ǔ
        DEADTRANS(0x005a, 0x02c7, 0x017d, 0x0000), // Z -> Ž
        DEADTRANS(0x007a, 0x02c7, 0x017e, 0x0000), // z -> ž
        DEADTRANS(0x0030, 0x02c7, 0x2080, 0x0000), // 0 -> ₀
        DEADTRANS(0x0031, 0x02c7, 0x2081, 0x0000), // 1 -> ₁
        DEADTRANS(0x0032, 0x02c7, 0x2082, 0x0000), // 2 -> ₂
        DEADTRANS(0x0033, 0x02c7, 0x2083, 0x0000), // 3 -> ₃
        DEADTRANS(0x0034, 0x02c7, 0x2084, 0x0000), // 4 -> ₄
        DEADTRANS(0x0035, 0x02c7, 0x2085, 0x0000), // 5 -> ₅
        DEADTRANS(0x0036, 0x02c7, 0x2086, 0x0000), // 6 -> ₆
        DEADTRANS(0x0037, 0x02c7, 0x2087, 0x0000), // 7 -> ₇
        DEADTRANS(0x0038, 0x02c7, 0x2088, 0x0000), // 8 -> ₈
        DEADTRANS(0x0039, 0x02c7, 0x2089, 0x0000), // 9 -> ₉
        DEADTRANS(0x0028, 0x02c7, 0x208d, 0x0000), // ( -> ₍
        DEADTRANS(0x0029, 0x02c7, 0x208e, 0x0000), // ) -> ₎
        DEADTRANS(0x002b, 0x02c7, 0x208a, 0x0000), // + -> ₊
        DEADTRANS(0x002d, 0x02c7, 0x208b, 0x0000), // - -> ₋
        DEADTRANS(0x003d, 0x02c7, 0x208c, 0x0000), // = -> ₌
        DEADTRANS(0x0020, 0x02c7, 0x02c7, 0x0000), //   -> ˇ
        DEADTRANS(0x00a0, 0x02c7, 0x02c7, 0x0000), //   -> ˇ
        DEADTRANS(0x202f, 0x02c7, 0x02c7, 0x0000), //   -> ˇ

        // DEADKEY: BREVE
        DEADTRANS(0x0041, 0x02d8, 0x0102, 0x0000), // A -> Ă
        DEADTRANS(0x0061, 0x02d8, 0x0103, 0x0000), // a -> ă
        DEADTRANS(0x0045, 0x02d8, 0x0114, 0x0000), // E -> Ĕ
        DEADTRANS(0x0065, 0x02d8, 0x0115, 0x0000), // e -> ĕ
        DEADTRANS(0x0047, 0x02d8, 0x011e, 0x0000), // G -> Ğ
        DEADTRANS(0x0067, 0x02d8, 0x011f, 0x0000), // g -> ğ
        DEADTRANS(0x0049, 0x02d8, 0x012c, 0x0000), // I -> Ĭ
        DEADTRANS(0x0069, 0x02d8, 0x012d, 0x0000), // i -> ĭ
        DEADTRANS(0x004f, 0x02d8, 0x014e, 0x0000), // O -> Ŏ
        DEADTRANS(0x006f, 0x02d8, 0x014f, 0x0000), // o -> ŏ
        DEADTRANS(0x0055, 0x02d8, 0x016c, 0x0000), // U -> Ŭ
        DEADTRANS(0x0075, 0x02d8, 0x016d, 0x0000), // u -> ŭ
        DEADTRANS(0x0020, 0x02d8, 0x02d8, 0x0000), //   -> ˘
        DEADTRANS(0x00a0, 0x02d8, 0x02d8, 0x0000), //   -> ˘
        DEADTRANS(0x202f, 0x02d8, 0x02d8, 0x0000), //   -> ˘

        // DEADKEY: TILDE
        DEADTRANS(0x0041, 0x007e, 0x00c3, 0x0000), // A -> Ã
        DEADTRANS(0x0061, 0x007e, 0x00e3, 0x0000), // a -> ã
        DEADTRANS(0x0045, 0x007e, 0x1ebc, 0x0000), // E -> Ẽ
        DEADTRANS(0x0065, 0x007e, 0x1ebd, 0x0000), // e -> ẽ
        DEADTRANS(0x0049, 0x007e, 0x0128, 0x0000), // I -> Ĩ
        DEADTRANS(0x0069, 0x007e, 0x0129, 0x0000), // i -> ĩ
        DEADTRANS(0x004e, 0x007e, 0x00d1, 0x0000), // N -> Ñ
        DEADTRANS(0x006e, 0x007e, 0x00f1, 0x0000), // n -> ñ
        DEADTRANS(0x004f, 0x007e, 0x00d5, 0x0000), // O -> Õ
        DEADTRANS(0x006f, 0x007e, 0x00f5, 0x0000), // o -> õ
        DEADTRANS(0x0055, 0x007e, 0x0168, 0x0000), // U -> Ũ
        DEADTRANS(0x0075, 0x007e, 0x0169, 0x0000), // u -> ũ
        DEADTRANS(0x0056, 0x007e, 0x1e7c, 0x0000), // V -> Ṽ
        DEADTRANS(0x0076, 0x007e, 0x1e7d, 0x0000), // v -> ṽ
        DEADTRANS(0x0059, 0x007e, 0x1ef8, 0x0000), // Y -> Ỹ
        DEADTRANS(0x0079, 0x007e, 0x1ef9, 0x0000), // y -> ỹ
        DEADTRANS(0x003c, 0x007e, 0x2272, 0x0000), // < -> ≲
        DEADTRANS(0x003e, 0x007e, 0x2273, 0x0000), // > -> ≳
        DEADTRANS(0x003d, 0x007e, 0x2243, 0x0000), // = -> ≃
        DEADTRANS(0x0020, 0x007e, 0x007e, 0x0000), //   -> ~
        DEADTRANS(0x00a0, 0x007e, 0x007e, 0x0000), //   -> ~
        DEADTRANS(0x202f, 0x007e, 0x007e, 0x0000), //   -> ~

        // DEADKEY: MACRON
        DEADTRANS(0x00af, 0x00af, 0x02c9, 0x0000), // ¯ -> ˉ
        DEADTRANS(0x0041, 0x00af, 0x0100, 0x0000), // A -> Ā
        DEADTRANS(0x0061, 0x00af, 0x0101, 0x0000), // a -> ā
        DEADTRANS(0x0045, 0x00af, 0x0112, 0x0000), // E -> Ē
        DEADTRANS(0x0065, 0x00af, 0x0113, 0x0000), // e -> ē
        DEADTRANS(0x0047, 0x00af, 0x1e20, 0x0000), // G -> Ḡ
        DEADTRANS(0x0067, 0x00af, 0x1e21, 0x0000), // g -> ḡ
        DEADTRANS(0x0049, 0x00af, 0x012a, 0x0000), // I -> Ī
        DEADTRANS(0x0069, 0x00af, 0x012b, 0x0000), // i -> ī
        DEADTRANS(0x004f, 0x00af, 0x014c, 0x0000), // O -> Ō
        DEADTRANS(0x006f, 0x00af, 0x014d, 0x0000), // o -> ō
        DEADTRANS(0x0055, 0x00af, 0x016a, 0x0000), // U -> Ū
        DEADTRANS(0x0075, 0x00af, 0x016b, 0x0000), // u -> ū
        DEADTRANS(0x0059, 0x00af, 0x0232, 0x0000), // Y -> Ȳ
        DEADTRANS(0x0079, 0x00af, 0x0233, 0x0000), // y -> ȳ
        DEADTRANS(0x0020, 0x00af, 0x00af, 0x0000), //   -> ¯
        DEADTRANS(0x00a0, 0x00af, 0x00af, 0x0000), //   -> ¯
        DEADTRANS(0x202f, 0x00af, 0x00af, 0x0000), //   -> ¯

        // DEADKEY: DIAERESIS
        DEADTRANS(0x0041, 0x0022, 0x00c4, 0x0000), // A -> Ä
        DEADTRANS(0x0061, 0x0022, 0x00e4, 0x0000), // a -> ä
        DEADTRANS(0x0045, 0x0022, 0x00cb, 0x0000), // E -> Ë
        DEADTRANS(0x0065, 0x0022, 0x00eb, 0x0000), // e -> ë
        DEADTRANS(0x0048, 0x0022, 0x1e26, 0x0000), // H -> Ḧ
        DEADTRANS(0x0068, 0x0022, 0x1e27, 0x0000), // h -> ḧ
        DEADTRANS(0x0049, 0x0022, 0x00cf, 0x0000), // I -> Ï
        DEADTRANS(0x0069, 0x0022, 0x00ef, 0x0000), // i -> ï
        DEADTRANS(0x004f, 0x0022, 0x00d6, 0x0000), // O -> Ö
        DEADTRANS(0x006f, 0x0022, 0x00f6, 0x0000), // o -> ö
        DEADTRANS(0x0074, 0x0022, 0x1e97, 0x0000), // t -> ẗ
        DEADTRANS(0x0055, 0x0022, 0x00dc, 0x0000), // U -> Ü
        DEADTRANS(0x0075, 0x0022, 0x00fc, 0x0000), // u -> ü
        DEADTRANS(0x0057, 0x0022, 0x1e84, 0x0000), // W -> Ẅ
        DEADTRANS(0x0077, 0x0022, 0x1e85, 0x0000), // w -> ẅ
        DEADTRANS(0x0058, 0x0022, 0x1e8c, 0x0000), // X -> Ẍ
        DEADTRANS(0x0078, 0x0022, 0x1e8d, 0x0000), // x -> ẍ
        DEADTRANS(0x0059, 0x0022, 0x0178, 0x0000), // Y -> Ÿ
        DEADTRANS(0x0079, 0x0022, 0x00ff, 0x0000), // y -> ÿ
        DEADTRANS(0x0020, 0x0022, 0x0022, 0x0000), //   -> "
        DEADTRANS(0x00a0, 0x0022, 0x0022, 0x0000), //   -> "
        DEADTRANS(0x202f, 0x0022, 0x0022, 0x0000), //   -> "

        // DEADKEY: ABOVERING
        DEADTRANS(0x0041, 0x02da, 0x00c5, 0x0000), // A -> Å
        DEADTRANS(0x0061, 0x02da, 0x00e5, 0x0000), // a -> å
        DEADTRANS(0x0055, 0x02da, 0x016e, 0x0000), // U -> Ů
        DEADTRANS(0x0075, 0x02da, 0x016f, 0x0000), // u -> ů
        DEADTRANS(0x0077, 0x02da, 0x1e98, 0x0000), // w -> ẘ
        DEADTRANS(0x0079, 0x02da, 0x1e99, 0x0000), // y -> ẙ
        DEADTRANS(0x0020, 0x02da, 0x02da, 0x0000), //   -> ˚
        DEADTRANS(0x00a0, 0x02da, 0x02da, 0x0000), //   -> ˚
        DEADTRANS(0x202f, 0x02da, 0x02da, 0x0000), //   -> ˚

        // DEADKEY: CEDILLA
        DEADTRANS(0x0043, 0x00b8, 0x00c7, 0x0000), // C -> Ç
        DEADTRANS(0x0063, 0x00b8, 0x00e7, 0x0000), // c -> ç
        DEADTRANS(0x0044, 0x00b8, 0x1e10, 0x0000), // D -> Ḑ
        DEADTRANS(0x0064, 0x00b8, 0x1e11, 0x0000), // d -> ḑ
        DEADTRANS(0x0045, 0x00b8, 0x0228, 0x0000), // E -> Ȩ
        DEADTRANS(0x0065, 0x00b8, 0x0229, 0x0000), // e -> ȩ
        DEADTRANS(0x0047, 0x00b8, 0x0122, 0x0000), // G -> Ģ
        DEADTRANS(0x0067, 0x00b8, 0x0123, 0x0000), // g -> ģ
        DEADTRANS(0x0048, 0x00b8, 0x1e28, 0x0000), // H -> Ḩ
        DEADTRANS(0x0068, 0x00b8, 0x1e29, 0x0000), // h -> ḩ
        DEADTRANS(0x004b, 0x00b8, 0x0136, 0x0000), // K -> Ķ
        DEADTRANS(0x006b, 0x00b8, 0x0137, 0x0000), // k -> ķ
        DEADTRANS(0x004c, 0x00b8, 0x013b, 0x0000), // L -> Ļ
        DEADTRANS(0x006c, 0x00b8, 0x013c, 0x0000), // l -> ļ
        DEADTRANS(0x004e, 0x00b8, 0x0145, 0x0000), // N -> Ņ
        DEADTRANS(0x006e, 0x00b8, 0x0146, 0x0000), // n -> ņ
        DEADTRANS(0x0052, 0x00b8, 0x0156, 0x0000), // R -> Ŗ
        DEADTRANS(0x0072, 0x00b8, 0x0157, 0x0000), // r -> ŗ
        DEADTRANS(0x0053, 0x00b8, 0x015e, 0x0000), // S -> Ş
        DEADTRANS(0x0073, 0x00b8, 0x015f, 0x0000), // s -> ş
        DEADTRANS(0x0054, 0x00b8, 0x0162, 0x0000), // T -> Ţ
        DEADTRANS(0x0074, 0x00b8, 0x0163, 0x0000), // t -> ţ
        DEADTRANS(0x0020, 0x00b8, 0x00b8, 0x0000), //   -> ¸
        DEADTRANS(0x00a0, 0x00b8, 0x00b8, 0x0000), //   -> ¸
        DEADTRANS(0x202f, 0x00b8, 0x00b8, 0x0000), //   -> ¸

        // DEADKEY: BELOWCOMMA
        DEADTRANS(0x0053, 0x002c, 0x0218, 0x0000), // S -> Ș
        DEADTRANS(0x0073, 0x002c, 0x0219, 0x0000), // s -> ș
        DEADTRANS(0x0054, 0x002c, 0x021a, 0x0000), // T -> Ț
        DEADTRANS(0x0074, 0x002c, 0x021b, 0x0000), // t -> ț
        DEADTRANS(0x0020, 0x002c, 0x002c, 0x0000), //   -> ,
        DEADTRANS(0x00a0, 0x002c, 0x002c, 0x0000), //   -> ,
        DEADTRANS(0x202f, 0x002c, 0x002c, 0x0000), //   -> ,

        // DEADKEY: OGONEK
        DEADTRANS(0x0041, 0x02db, 0x0104, 0x0000), // A -> Ą
        DEADTRANS(0x0061, 0x02db, 0x0105, 0x0000), // a -> ą
        DEADTRANS(0x0045, 0x02db, 0x0118, 0x0000), // E -> Ę
        DEADTRANS(0x0065, 0x02db, 0x0119, 0x0000), // e -> ę
        DEADTRANS(0x0049, 0x02db, 0x012e, 0x0000), // I -> Į
        DEADTRANS(0x0069, 0x02db, 0x012f, 0x0000), // i -> į
        DEADTRANS(0x004f, 0x02db, 0x01ea, 0x0000), // O -> Ǫ
        DEADTRANS(0x006f, 0x02db, 0x01eb, 0x0000), // o -> ǫ
        DEADTRANS(0x0055, 0x02db, 0x0172, 0x0000), // U -> Ų
        DEADTRANS(0x0075, 0x02db, 0x0173, 0x0000), // u -> ų
        DEADTRANS(0x0020, 0x02db, 0x02db, 0x0000), //   -> ˛
        DEADTRANS(0x00a0, 0x02db, 0x02db, 0x0000), //   -> ˛
        DEADTRANS(0x202f, 0x02db, 0x02db, 0x0000), //   -> ˛

        // DEADKEY: STROKE
        DEADTRANS(0x0041, 0x002f, 0x023a, 0x0000), // A -> Ⱥ
        DEADTRANS(0x0061, 0x002f, 0x2c65, 0x0000), // a -> ⱥ
        DEADTRANS(0x0042, 0x002f, 0x0243, 0x0000), // B -> Ƀ
        DEADTRANS(0x0062, 0x002f, 0x0180, 0x0000), // b -> ƀ
        DEADTRANS(0x0043, 0x002f, 0x023b, 0x0000), // C -> Ȼ
        DEADTRANS(0x0063, 0x002f, 0x023c, 0x0000), // c -> ȼ
        DEADTRANS(0x0044, 0x002f, 0x0110, 0x0000), // D -> Đ
        DEADTRANS(0x0064, 0x002f, 0x0111, 0x0000), // d -> đ
        DEADTRANS(0x0045, 0x002f, 0x0246, 0x0000), // E -> Ɇ
        DEADTRANS(0x0065, 0x002f, 0x0247, 0x0000), // e -> ɇ
        DEADTRANS(0x0047, 0x002f, 0x01e4, 0x0000), // G -> Ǥ
        DEADTRANS(0x0067, 0x002f, 0x01e5, 0x0000), // g -> ǥ
        DEADTRANS(0x0048, 0x002f, 0x0126, 0x0000), // H -> Ħ
        DEADTRANS(0x0068, 0x002f, 0x0127, 0x0000), // h -> ħ
        DEADTRANS(0x0049, 0x002f, 0x0197, 0x0000), // I -> Ɨ
        DEADTRANS(0x0069, 0x002f, 0x0268, 0x0000), // i -> ɨ
        DEADTRANS(0x004a, 0x002f, 0x0248, 0x0000), // J -> Ɉ
        DEADTRANS(0x006a, 0x002f, 0x0249, 0x0000), // j -> ɉ
        DEADTRANS(0x004c, 0x002f, 0x0141, 0x0000), // L -> Ł
        DEADTRANS(0x006c, 0x002f, 0x0142, 0x0000), // l -> ł
        DEADTRANS(0x004f, 0x002f, 0x00d8, 0x0000), // O -> Ø
        DEADTRANS(0x006f, 0x002f, 0x00f8, 0x0000), // o -> ø
        DEADTRANS(0x0050, 0x002f, 0x2c63, 0x0000), // P -> Ᵽ
        DEADTRANS(0x0070, 0x002f, 0x1d7d, 0x0000), // p -> ᵽ
        DEADTRANS(0x0052, 0x002f, 0x024c, 0x0000), // R -> Ɍ
        DEADTRANS(0x0072, 0x002f, 0x024d, 0x0000), // r -> ɍ
        DEADTRANS(0x0054, 0x002f, 0x0166, 0x0000), // T -> Ŧ
        DEADTRANS(0x0074, 0x002f, 0x0167, 0x0000), // t -> ŧ
        DEADTRANS(0x0055, 0x002f, 0x0244, 0x0000), // U -> Ʉ
        DEADTRANS(0x0075, 0x002f, 0x0289, 0x0000), // u -> ʉ
        DEADTRANS(0x0059, 0x002f, 0x024e, 0x0000), // Y -> Ɏ
        DEADTRANS(0x0079, 0x002f, 0x024f, 0x0000), // y -> ɏ
        DEADTRANS(0x005a, 0x002f, 0x01b5, 0x0000), // Z -> Ƶ
        DEADTRANS(0x007a, 0x002f, 0x01b6, 0x0000), // z -> ƶ
        DEADTRANS(0x003c, 0x002f, 0x226e, 0x0000), // < -> ≮
        DEADTRANS(0x2264, 0x002f, 0x2270, 0x0000), // ≤ -> ≰
        DEADTRANS(0x2265, 0x002f, 0x2271, 0x0000), // ≥ -> ≱
        DEADTRANS(0x003e, 0x002f, 0x226f, 0x0000), // > -> ≯
        DEADTRANS(0x003d, 0x002f, 0x2260, 0x0000), // = -> ≠
        DEADTRANS(0x0020, 0x002f, 0x002f, 0x0000), //   -> /
        DEADTRANS(0x00a0, 0x002f, 0x002f, 0x0000), //   -> /
        DEADTRANS(0x202f, 0x002f, 0x002f, 0x0000), //   -> /

        // DEADKEY: ABOVEDOT
        DEADTRANS(0x0041, 0x02d9, 0x0226, 0x0000), // A -> Ȧ
        DEADTRANS(0x0061, 0x02d9, 0x0227, 0x0000), // a -> ȧ
        DEADTRANS(0x0042, 0x02d9, 0x1e02, 0x0000), // B -> Ḃ
        DEADTRANS(0x0062, 0x02d9, 0x1e03, 0x0000), // b -> ḃ
        DEADTRANS(0x0043, 0x02d9, 0x010a, 0x0000), // C -> Ċ
        DEADTRANS(0x0063, 0x02d9, 0x010b, 0x0000), // c -> ċ
        DEADTRANS(0x0044, 0x02d9, 0x1e0a, 0x0000), // D -> Ḋ
        DEADTRANS(0x0064, 0x02d9, 0x1e0b, 0x0000), // d -> ḋ
        DEADTRANS(0x0045, 0x02d9, 0x0116, 0x0000), // E -> Ė
        DEADTRANS(0x0065, 0x02d9, 0x0117, 0x0000), // e -> ė
        DEADTRANS(0x0046, 0x02d9, 0x1e1e, 0x0000), // F -> Ḟ
        DEADTRANS(0x0066, 0x02d9, 0x1e1f, 0x0000), // f -> ḟ
        DEADTRANS(0x0047, 0x02d9, 0x0120, 0x0000), // G -> Ġ
        DEADTRANS(0x0067, 0x02d9, 0x0121, 0x0000), // g -> ġ
        DEADTRANS(0x0048, 0x02d9, 0x1e22, 0x0000), // H -> Ḣ
        DEADTRANS(0x0068, 0x02d9, 0x1e23, 0x0000), // h -> ḣ
        DEADTRANS(0x0049, 0x02d9, 0x0130, 0x0000), // I -> İ
        DEADTRANS(0x0069, 0x02d9, 0x0131, 0x0000), // i -> ı
        DEADTRANS(0x006a, 0x02d9, 0x0237, 0x0000), // j -> ȷ
        DEADTRANS(0x004c, 0x02d9, 0x013f, 0x0000), // L -> Ŀ
        DEADTRANS(0x006c, 0x02d9, 0x0140, 0x0000), // l -> ŀ
        DEADTRANS(0x004d, 0x02d9, 0x1e40, 0x0000), // M -> Ṁ
        DEADTRANS(0x006d, 0x02d9, 0x1e41, 0x0000), // m -> ṁ
        DEADTRANS(0x004e, 0x02d9, 0x1e44, 0x0000), // N -> Ṅ
        DEADTRANS(0x006e, 0x02d9, 0x1e45, 0x0000), // n -> ṅ
        DEADTRANS(0x004f, 0x02d9, 0x022e, 0x0000), // O -> Ȯ
        DEADTRANS(0x006f, 0x02d9, 0x022f, 0x0000), // o -> ȯ
        DEADTRANS(0x0050, 0x02d9, 0x1e56, 0x0000), // P -> Ṗ
        DEADTRANS(0x0070, 0x02d9, 0x1e57, 0x0000), // p -> ṗ
        DEADTRANS(0x0052, 0x02d9, 0x1e58, 0x0000), // R -> Ṙ
        DEADTRANS(0x0072, 0x02d9, 0x1e59, 0x0000), // r -> ṙ
        DEADTRANS(0x0053, 0x02d9, 0x1e60, 0x0000), // S -> Ṡ
        DEADTRANS(0x0073, 0x02d9, 0x1e61, 0x0000), // s -> ṡ
        DEADTRANS(0x0054, 0x02d9, 0x1e6a, 0x0000), // T -> Ṫ
        DEADTRANS(0x0074, 0x02d9, 0x1e6b, 0x0000), // t -> ṫ
        DEADTRANS(0x0057, 0x02d9, 0x1e86, 0x0000), // W -> Ẇ
        DEADTRANS(0x0077, 0x02d9, 0x1e87, 0x0000), // w -> ẇ
        DEADTRANS(0x0058, 0x02d9, 0x1e8a, 0x0000), // X -> Ẋ
        DEADTRANS(0x0078, 0x02d9, 0x1e8b, 0x0000), // x -> ẋ
        DEADTRANS(0x0059, 0x02d9, 0x1e8e, 0x0000), // Y -> Ẏ
        DEADTRANS(0x0079, 0x02d9, 0x1e8f, 0x0000), // y -> ẏ
        DEADTRANS(0x005a, 0x02d9, 0x017b, 0x0000), // Z -> Ż
        DEADTRANS(0x007a, 0x02d9, 0x017c, 0x0000), // z -> ż
        DEADTRANS(0x0020, 0x02d9, 0x02d9, 0x0000), //   -> ˙
        DEADTRANS(0x00a0, 0x02d9, 0x02d9, 0x0000), //   -> ˙
        DEADTRANS(0x202f, 0x02d9, 0x02d9, 0x0000), //   -> ˙

        // DEADKEY: GREEK
        DEADTRANS(0x0041, 0x00b5, 0x0391, 0x0000), // A -> Α
        DEADTRANS(0x0061, 0x00b5, 0x03b1, 0x0000), // a -> α
        DEADTRANS(0x0042, 0x00b5, 0x0392, 0x0000), // B -> Β
        DEADTRANS(0x0062, 0x00b5, 0x03b2, 0x0000), // b -> β
        DEADTRANS(0x0044, 0x00b5, 0x0394, 0x0000), // D -> Δ
        DEADTRANS(0x0064, 0x00b5, 0x03b4, 0x0000), // d -> δ
        DEADTRANS(0x0045, 0x00b5, 0x0395, 0x0000), // E -> Ε
        DEADTRANS(0x0065, 0x00b5, 0x03b5, 0x0000), // e -> ε
        DEADTRANS(0x0046, 0x00b5, 0x03a6, 0x0000), // F -> Φ
        DEADTRANS(0x0066, 0x00b5, 0x03c6, 0x0000), // f -> φ
        DEADTRANS(0x0047, 0x00b5, 0x0393, 0x0000), // G -> Γ
        DEADTRANS(0x0067, 0x00b5, 0x03b3, 0x0000), // g -> γ
        DEADTRANS(0x0048, 0x00b5, 0x0397, 0x0000), // H -> Η
        DEADTRANS(0x0068, 0x00b5, 0x03b7, 0x0000), // h -> η
        DEADTRANS(0x0049, 0x00b5, 0x0399, 0x0000), // I -> Ι
        DEADTRANS(0x0069, 0x00b5, 0x03b9, 0x0000), // i -> ι
        DEADTRANS(0x004a, 0x00b5, 0x0398, 0x0000), // J -> Θ
        DEADTRANS(0x006a, 0x00b5, 0x03b8, 0x0000), // j -> θ
        DEADTRANS(0x004b, 0x00b5, 0x039a, 0x0000), // K -> Κ
        DEADTRANS(0x006b, 0x00b5, 0x03ba, 0x0000), // k -> κ
        DEADTRANS(0x004c, 0x00b5, 0x039b, 0x0000), // L -> Λ
        DEADTRANS(0x006c, 0x00b5, 0x03bb, 0x0000), // l -> λ
        DEADTRANS(0x004d, 0x00b5, 0x039c, 0x0000), // M -> Μ
        DEADTRANS(0x006d, 0x00b5, 0x03bc, 0x0000), // m -> μ
        DEADTRANS(0x004e, 0x00b5, 0x039d, 0x0000), // N -> Ν
        DEADTRANS(0x006e, 0x00b5, 0x03bd, 0x0000), // n -> ν
        DEADTRANS(0x004f, 0x00b5, 0x039f, 0x0000), // O -> Ο
        DEADTRANS(0x006f, 0x00b5, 0x03bf, 0x0000), // o -> ο
        DEADTRANS(0x0050, 0x00b5, 0x03a0, 0x0000), // P -> Π
        DEADTRANS(0x0070, 0x00b5, 0x03c0, 0x0000), // p -> π
        DEADTRANS(0x0051, 0x00b5, 0x03a7, 0x0000), // Q -> Χ
        DEADTRANS(0x0071, 0x00b5, 0x03c7, 0x0000), // q -> χ
        DEADTRANS(0x0052, 0x00b5, 0x03a1, 0x0000), // R -> Ρ
        DEADTRANS(0x0072, 0x00b5, 0x03c1, 0x0000), // r -> ρ
        DEADTRANS(0x0053, 0x00b5, 0x03a3, 0x0000), // S -> Σ
        DEADTRANS(0x0073, 0x00b5, 0x03c3, 0x0000), // s -> σ
        DEADTRANS(0x0054, 0x00b5, 0x03a4, 0x0000), // T -> Τ
        DEADTRANS(0x0074, 0x00b5, 0x03c4, 0x0000), // t -> τ
        DEADTRANS(0x0055, 0x00b5, 0x03a5, 0x0000), // U -> Υ
        DEADTRANS(0x0075, 0x00b5, 0x03c5, 0x0000), // u -> υ
        DEADTRANS(0x0057, 0x00b5, 0x03a9, 0x0000), // W -> Ω
        DEADTRANS(0x0077, 0x00b5, 0x03c9, 0x0000), // w -> ω
        DEADTRANS(0x0058, 0x00b5, 0x039e, 0x0000), // X -> Ξ
        DEADTRANS(0x0078, 0x00b5, 0x03be, 0x0000), // x -> ξ
        DEADTRANS(0x0059, 0x00b5, 0x03a8, 0x0000), // Y -> Ψ
        DEADTRANS(0x0079, 0x00b5, 0x03c8, 0x0000), // y -> ψ
        DEADTRANS(0x005a, 0x00b5, 0x0396, 0x0000), // Z -> Ζ
        DEADTRANS(0x007a, 0x00b5, 0x03b6, 0x0000), // z -> ζ
        DEADTRANS(0x0020, 0x00b5, 0x00b5, 0x0000), //   -> µ
        DEADTRANS(0x00a0, 0x00b5, 0x00b5, 0x0000), //   -> µ
        DEADTRANS(0x202f, 0x00b5, 0x00b5, 0x0000), //   -> µ

        // DEADKEY: CURRENCY
        DEADTRANS(0x0041, 0x00a4, 0x20b3, 0x0000), // A -> ₳
        DEADTRANS(0x0061, 0x00a4, 0x060b, 0x0000), // a -> ؋
        DEADTRANS(0x0042, 0x00a4, 0x20b1, 0x0000), // B -> ₱
        DEADTRANS(0x0062, 0x00a4, 0x0e3f, 0x0000), // b -> ฿
        DEADTRANS(0x0043, 0x00a4, 0x20a1, 0x0000), // C -> ₡
        DEADTRANS(0x0063, 0x00a4, 0x00a2, 0x0000), // c -> ¢
        DEADTRANS(0x0044, 0x00a4, 0x20af, 0x0000), // D -> ₯
        DEADTRANS(0x0064, 0x00a4, 0x20ab, 0x0000), // d -> ₫
        DEADTRANS(0x0045, 0x00a4, 0x20a0, 0x0000), // E -> ₠
        DEADTRANS(0x0065, 0x00a4, 0x20ac, 0x0000), // e -> €
        DEADTRANS(0x0046, 0x00a4, 0x20a3, 0x0000), // F -> ₣
        DEADTRANS(0x0066, 0x00a4, 0x0192, 0x0000), // f -> ƒ
        DEADTRANS(0x0047, 0x00a4, 0x20b2, 0x0000), // G -> ₲
        DEADTRANS(0x0067, 0x00a4, 0x20b2, 0x0000), // g -> ₲
        DEADTRANS(0x0048, 0x00a4, 0x20b4, 0x0000), // H -> ₴
        DEADTRANS(0x0068, 0x00a4, 0x20b4, 0x0000), // h -> ₴
        DEADTRANS(0x0049, 0x00a4, 0x17db, 0x0000), // I -> ៛
        DEADTRANS(0x0069, 0x00a4, 0xfdfc, 0x0000), // i -> ﷼
        DEADTRANS(0x004b, 0x00a4, 0x20ad, 0x0000), // K -> ₭
        DEADTRANS(0x006b, 0x00a4, 0x20ad, 0x0000), // k -> ₭
        DEADTRANS(0x004c, 0x00a4, 0x20a4, 0x0000), // L -> ₤
        DEADTRANS(0x006c, 0x00a4, 0x00a3, 0x0000), // l -> £
        DEADTRANS(0x004d, 0x00a4, 0x2133, 0x0000), // M -> ℳ
        DEADTRANS(0x006d, 0x00a4, 0x20a5, 0x0000), // m -> ₥
        DEADTRANS(0x004e, 0x00a4, 0x20a6, 0x0000), // N -> ₦
        DEADTRANS(0x006e, 0x00a4, 0x20a6, 0x0000), // n -> ₦
        DEADTRANS(0x004f, 0x00a4, 0x0af1, 0x0000), // O -> ૱
        DEADTRANS(0x006f, 0x00a4, 0x0bf9, 0x0000), // o -> ௹
        DEADTRANS(0x0050, 0x00a4, 0x20a7, 0x0000), // P -> ₧
        DEADTRANS(0x0070, 0x00a4, 0x20b0, 0x0000), // p -> ₰
        DEADTRANS(0x0052, 0x00a4, 0x20a8, 0x0000), // R -> ₨
        DEADTRANS(0x0072, 0x00a4, 0x20a2, 0x0000), // r -> ₢
        DEADTRANS(0x0053, 0x00a4, 0x0024, 0x0000), // S -> $
        DEADTRANS(0x0073, 0x00a4, 0x20aa, 0x0000), // s -> ₪
        DEADTRANS(0x0054, 0x00a4, 0x20ae, 0x0000), // T -> ₮
        DEADTRANS(0x0074, 0x00a4, 0x09f3, 0x0000), // t -> ৳
        DEADTRANS(0x0055, 0x00a4, 0x5713, 0x0000), // U -> 圓
        DEADTRANS(0x0075, 0x00a4, 0x5143, 0x0000), // u -> 元
        DEADTRANS(0x0057, 0x00a4, 0x20a9, 0x0000), // W -> ₩
        DEADTRANS(0x0077, 0x00a4, 0x20a9, 0x0000), // w -> ₩
        DEADTRANS(0x0059, 0x00a4, 0x5186, 0x0000), // Y -> 円
        DEADTRANS(0x0079, 0x00a4, 0x00a5, 0x0000), // y -> ¥
        DEADTRANS(0x0020, 0x00a4, 0x00a4, 0x0000), //   -> ¤
        DEADTRANS(0x00a0, 0x00a4, 0x00a4, 0x0000), //   -> ¤
        DEADTRANS(0x202f, 0x00a4, 0x00a4, 0x0000), //   -> ¤

        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        DEADKEY{
            .dwBoth = 0,
            .wchComposed = 0,
            .uFlags = 0,
        },
    };

    // key_names, key_names_ext - Virtual Scancode to Key Name tables
    //
    // Table attributes: Ordered Scan (by scancode), null-terminated
    //
    // Only the names of Extended, NumPad, Dead and Non-Printable keys are here.
    // (Keys producing printable characters are named by that character)
    var key_names = [_]VSC_LPWSTR{
        VSC_LPWSTR{ .vsc = 0x01, .pwsz = L("Esc") },
        VSC_LPWSTR{ .vsc = 0x0e, .pwsz = L("Backspace") },
        VSC_LPWSTR{ .vsc = 0x0f, .pwsz = L("Tab") },
        VSC_LPWSTR{ .vsc = 0x1c, .pwsz = L("Enter") },
        VSC_LPWSTR{ .vsc = 0x1d, .pwsz = L("Ctrl") },
        VSC_LPWSTR{ .vsc = 0x2a, .pwsz = L("Shift") },
        VSC_LPWSTR{ .vsc = 0x36, .pwsz = L("Right Shift") },
        VSC_LPWSTR{ .vsc = 0x37, .pwsz = L("Num *") },
        VSC_LPWSTR{ .vsc = 0x38, .pwsz = L("Alt") },
        VSC_LPWSTR{ .vsc = 0x39, .pwsz = L("Space") },
        VSC_LPWSTR{ .vsc = 0x3a, .pwsz = L("Caps Lock") },
        VSC_LPWSTR{ .vsc = 0x3b, .pwsz = L("F1") },
        VSC_LPWSTR{ .vsc = 0x3c, .pwsz = L("F2") },
        VSC_LPWSTR{ .vsc = 0x3d, .pwsz = L("F3") },
        VSC_LPWSTR{ .vsc = 0x3e, .pwsz = L("F4") },
        VSC_LPWSTR{ .vsc = 0x3f, .pwsz = L("F5") },
        VSC_LPWSTR{ .vsc = 0x40, .pwsz = L("F6") },
        VSC_LPWSTR{ .vsc = 0x41, .pwsz = L("F7") },
        VSC_LPWSTR{ .vsc = 0x42, .pwsz = L("F8") },
        VSC_LPWSTR{ .vsc = 0x43, .pwsz = L("F9") },
        VSC_LPWSTR{ .vsc = 0x44, .pwsz = L("F10") },
        VSC_LPWSTR{ .vsc = 0x45, .pwsz = L("Pause") },
        VSC_LPWSTR{ .vsc = 0x46, .pwsz = L("Scroll Lock") },
        VSC_LPWSTR{ .vsc = 0x47, .pwsz = L("Num 7") },
        VSC_LPWSTR{ .vsc = 0x48, .pwsz = L("Num 8") },
        VSC_LPWSTR{ .vsc = 0x49, .pwsz = L("Num 9") },
        VSC_LPWSTR{ .vsc = 0x4a, .pwsz = L("Num -") },
        VSC_LPWSTR{ .vsc = 0x4b, .pwsz = L("Num 4") },
        VSC_LPWSTR{ .vsc = 0x4c, .pwsz = L("Num 5") },
        VSC_LPWSTR{ .vsc = 0x4d, .pwsz = L("Num 6") },
        VSC_LPWSTR{ .vsc = 0x4e, .pwsz = L("Num +") },
        VSC_LPWSTR{ .vsc = 0x4f, .pwsz = L("Num 1") },
        VSC_LPWSTR{ .vsc = 0x50, .pwsz = L("Num 2") },
        VSC_LPWSTR{ .vsc = 0x51, .pwsz = L("Num 3") },
        VSC_LPWSTR{ .vsc = 0x52, .pwsz = L("Num 0") },
        VSC_LPWSTR{ .vsc = 0x53, .pwsz = L("Num Del") },
        VSC_LPWSTR{ .vsc = 0x54, .pwsz = L("Sys Req") },
        VSC_LPWSTR{ .vsc = 0x57, .pwsz = L("F11") },
        VSC_LPWSTR{ .vsc = 0x58, .pwsz = L("F12") },
        VSC_LPWSTR{ .vsc = 0x7c, .pwsz = L("F13") },
        VSC_LPWSTR{ .vsc = 0x7d, .pwsz = L("F14") },
        VSC_LPWSTR{ .vsc = 0x7e, .pwsz = L("F15") },
        VSC_LPWSTR{ .vsc = 0x7f, .pwsz = L("F16") },
        VSC_LPWSTR{ .vsc = 0x80, .pwsz = L("F17") },
        VSC_LPWSTR{ .vsc = 0x81, .pwsz = L("F18") },
        VSC_LPWSTR{ .vsc = 0x82, .pwsz = L("F19") },
        VSC_LPWSTR{ .vsc = 0x83, .pwsz = L("F20") },
        VSC_LPWSTR{ .vsc = 0x84, .pwsz = L("F21") },
        VSC_LPWSTR{ .vsc = 0x85, .pwsz = L("F22") },
        VSC_LPWSTR{ .vsc = 0x86, .pwsz = L("F23") },
        VSC_LPWSTR{ .vsc = 0x87, .pwsz = L("F24") },

        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VSC_LPWSTR{ .vsc = 0, .pwsz = null },
    };

    var key_names_ext = [_]VSC_LPWSTR{
        VSC_LPWSTR{ .vsc = 0x1c, .pwsz = L("Num Enter") },
        VSC_LPWSTR{ .vsc = 0x1d, .pwsz = L("Right Ctrl") },
        VSC_LPWSTR{ .vsc = 0x35, .pwsz = L("Num /") },
        VSC_LPWSTR{ .vsc = 0x37, .pwsz = L("Prnt Scrn") },
        VSC_LPWSTR{ .vsc = 0x38, .pwsz = L("Right Alt") },
        VSC_LPWSTR{ .vsc = 0x45, .pwsz = L("Num Lock") },
        VSC_LPWSTR{ .vsc = 0x46, .pwsz = L("Break") },
        VSC_LPWSTR{ .vsc = 0x47, .pwsz = L("Home") },
        VSC_LPWSTR{ .vsc = 0x48, .pwsz = L("Up") },
        VSC_LPWSTR{ .vsc = 0x49, .pwsz = L("Page Up") },
        VSC_LPWSTR{ .vsc = 0x4b, .pwsz = L("Left") },
        VSC_LPWSTR{ .vsc = 0x4d, .pwsz = L("Right") },
        VSC_LPWSTR{ .vsc = 0x4f, .pwsz = L("End") },
        VSC_LPWSTR{ .vsc = 0x50, .pwsz = L("Down") },
        VSC_LPWSTR{ .vsc = 0x51, .pwsz = L("Page Down") },
        VSC_LPWSTR{ .vsc = 0x52, .pwsz = L("Insert") },
        VSC_LPWSTR{ .vsc = 0x53, .pwsz = L("Delete") },
        VSC_LPWSTR{ .vsc = 0x54, .pwsz = L("<00>") },
        VSC_LPWSTR{ .vsc = 0x56, .pwsz = L("Help") },
        VSC_LPWSTR{ .vsc = 0x5b, .pwsz = L("Left Windows") },
        VSC_LPWSTR{ .vsc = 0x5c, .pwsz = L("Right Windows") },
        VSC_LPWSTR{ .vsc = 0x5d, .pwsz = L("Application") },

        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VSC_LPWSTR{ .vsc = 0, .pwsz = null },
    };

    var key_names_dead = [_]DEADKEY_LPWSTR{
        // TODO: not sure about this translation from C to Zig
        // L"\x2019"	L"1DK",
        // L"\x0060"	L"GRAVE",
        // L"\x0027"	L"ACUTE",
        // L"\x201d"	L"DOUBLEACUTE",
        // L"\x005e"	L"CIRCUMFLEX",
        // L"\x02c7"	L"CARON",
        // L"\x02d8"	L"BREVE",
        // L"\x007e"	L"TILDE",
        // L"\x00af"	L"MACRON",
        // L"\x0022"	L"DIAERESIS",
        // L"\x02da"	L"ABOVERING",
        // L"\x00b8"	L"CEDILLA",
        // L"\x002c"	L"BELOWCOMMA",
        // L"\x02db"	L"OGONEK",
        // L"\x002f"	L"STROKE",
        // L"\x02d9"	L"ABOVEDOT",
        // L"\x00b5"	L"GREEK",
        // L"\x00a4"	L"CURRENCY",
        // NULL
        L("\x2019") ++ L("1DK"),
        L("\x0060") ++ L("GRAVE"),
        L("\x0027") ++ L("ACUTE"),
        L("\x201d") ++ L("DOUBLEACUTE"),
        L("\x005e") ++ L("CIRCUMFLEX"),
        L("\x02c7") ++ L("CARON"),
        L("\x02d8") ++ L("BREVE"),
        L("\x007e") ++ L("TILDE"),
        L("\x00af") ++ L("MACRON"),
        L("\x0022") ++ L("DIAERESIS"),
        L("\x02da") ++ L("ABOVERING"),
        L("\x00b8") ++ L("CEDILLA"),
        L("\x002c") ++ L("BELOWCOMMA"),
        L("\x02db") ++ L("OGONEK"),
        L("\x002f") ++ L("STROKE"),
        L("\x02d9") ++ L("ABOVEDOT"),
        L("\x00b5") ++ L("GREEK"),
        L("\x00a4") ++ L("CURRENCY"),

        // End pointer list with null
        // TODO: see if it must ends by null (sentinel)
        // ziglings 076_sentinels.zig
        null,
    };

    // Virtual Scan Code to Virtual Key conversion table
    var virtual_scan_codes_to_virtual_keys = [_]USHORT{
        T00, T01, T02, T03, T04, T05, T06,          T07,
        T08, T09, T0A, T0B, T0C, T0D, T0E,          T0F,
        T10, T11, T12, T13, T14, T15, T16,          T17,
        T18, T19, T1A, T1B, T1C, T1D, T1E,          T1F,
        T20, T21, T22, T23, T24, T25, T26,          T27,
        T28, T29, T2A, T2B, T2C, T2D, T2E,          T2F,
        T30, T31, T32, T33, T34, T35,

        // Right-hand Shift key must have KBDEXT bit set.
        T36 | KBDEXT,
        T37 | KBDMULTIVK, // numpad_* + Shift/Alt -> SnapShot

        T38,
        T39,
        T3A,
        T3B,
        T3C,
        T3D,
        T3E,
        T3F,
        T40,
        T41,
        T42,
        T43,
        T44,

        // NumLock Key:
        //     KBDEXT     - VK_NUMLOCK is an Extended key
        //     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
        T45 | KBDEXT | KBDMULTIVK,

        T46 | KBDMULTIVK,

        // Number Pad keys:
        //     KBDNUMPAD  - digits 0-9 and decimal point.
        //     KBDSPECIAL - require special processing by Windows
        T47 | KBDNUMPAD | KBDSPECIAL, // Numpad 7 (Home)
        T48 | KBDNUMPAD | KBDSPECIAL, // Numpad 8 (Up),
        T49 | KBDNUMPAD | KBDSPECIAL, // Numpad 9 (PgUp),
        T4A,
        T4B | KBDNUMPAD | KBDSPECIAL, // Numpad 4 (Left),
        T4C | KBDNUMPAD | KBDSPECIAL, // Numpad 5 (Clear),
        T4D | KBDNUMPAD | KBDSPECIAL, // Numpad 6 (Right),
        T4E,
        T4F | KBDNUMPAD | KBDSPECIAL, // Numpad 1 (End),
        T50 | KBDNUMPAD | KBDSPECIAL, // Numpad 2 (Down),
        T51 | KBDNUMPAD | KBDSPECIAL, // Numpad 3 (PgDn),
        T52 | KBDNUMPAD | KBDSPECIAL, // Numpad 0 (Ins),
        T53 | KBDNUMPAD | KBDSPECIAL, // Numpad . (Del),

        T54,
        T55,
        T56,
        T57,
        T58,
        T59,
        T5A,
        T5B,
        T5C,
        T5D,
        T5E,
        T5F,
        T60,
        T61,
        T62,
        T63,
        T64,
        T65,
        T66,
        T67,
        T68,
        T69,
        T6A,
        T6B,
        T6C,
        T6D,
        T6E,
        T6F,
        T70,
        T71,
        T72,
        T73,
        T74,
        T75,
        T76,
        T77,
        T78,
        T79,
        T7A,
        T7B,
        T7C,
        T7D,
        T7E,
    };

    var virtual_scan_codes_to_virtual_keys_e0 = [_]VSC_VK{
        VSC_VK{ .Vsc = 0x10, .Vk = X10 | KBDEXT }, // Speedracer: Previous Track
        VSC_VK{ .Vsc = 0x19, .Vk = X19 | KBDEXT }, // Speedracer: Next Track
        VSC_VK{ .Vsc = 0x1D, .Vk = X1D | KBDEXT }, // RControl
        VSC_VK{ .Vsc = 0x20, .Vk = X20 | KBDEXT }, // Speedracer: Volume Mute
        VSC_VK{ .Vsc = 0x21, .Vk = X21 | KBDEXT }, // Speedracer: Launch App 2
        VSC_VK{ .Vsc = 0x22, .Vk = X22 | KBDEXT }, // Speedracer: Media Play/Pause
        VSC_VK{ .Vsc = 0x24, .Vk = X24 | KBDEXT }, // Speedracer: Media Stop
        VSC_VK{ .Vsc = 0x2E, .Vk = X2E | KBDEXT }, // Speedracer: Volume Down
        VSC_VK{ .Vsc = 0x30, .Vk = X30 | KBDEXT }, // Speedracer: Volume Up
        VSC_VK{ .Vsc = 0x32, .Vk = X32 | KBDEXT }, // Speedracer: Browser Home
        VSC_VK{ .Vsc = 0x35, .Vk = X35 | KBDEXT }, // Numpad Divide
        VSC_VK{ .Vsc = 0x37, .Vk = X37 | KBDEXT }, // Snapshot
        VSC_VK{ .Vsc = 0x38, .Vk = X38 | KBDEXT }, // RMenu
        VSC_VK{ .Vsc = 0x47, .Vk = X47 | KBDEXT }, // Home
        VSC_VK{ .Vsc = 0x48, .Vk = X48 | KBDEXT }, // Up
        VSC_VK{ .Vsc = 0x49, .Vk = X49 | KBDEXT }, // Prior
        VSC_VK{ .Vsc = 0x4B, .Vk = X4B | KBDEXT }, // Left
        VSC_VK{ .Vsc = 0x4D, .Vk = X4D | KBDEXT }, // Right
        VSC_VK{ .Vsc = 0x4F, .Vk = X4F | KBDEXT }, // End
        VSC_VK{ .Vsc = 0x50, .Vk = X50 | KBDEXT }, // Down
        VSC_VK{ .Vsc = 0x51, .Vk = X51 | KBDEXT }, // Next
        VSC_VK{ .Vsc = 0x52, .Vk = X52 | KBDEXT }, // Insert
        VSC_VK{ .Vsc = 0x53, .Vk = X53 | KBDEXT }, // Delete
        VSC_VK{ .Vsc = 0x5B, .Vk = X5B | KBDEXT }, // Left Win
        VSC_VK{ .Vsc = 0x5C, .Vk = X5C | KBDEXT }, // Right Win
        VSC_VK{ .Vsc = 0x5D, .Vk = X5D | KBDEXT }, // Application
        VSC_VK{ .Vsc = 0x5F, .Vk = X5F | KBDEXT }, // Speedracer: Sleep
        VSC_VK{ .Vsc = 0x65, .Vk = X65 | KBDEXT }, // Speedracer: Browser Search
        VSC_VK{ .Vsc = 0x66, .Vk = X66 | KBDEXT }, // Speedracer: Browser Favorites
        VSC_VK{ .Vsc = 0x67, .Vk = X67 | KBDEXT }, // Speedracer: Browser Refresh
        VSC_VK{ .Vsc = 0x68, .Vk = X68 | KBDEXT }, // Speedracer: Browser Stop
        VSC_VK{ .Vsc = 0x69, .Vk = X69 | KBDEXT }, // Speedracer: Browser Forward
        VSC_VK{ .Vsc = 0x6A, .Vk = X6A | KBDEXT }, // Speedracer: Browser Back
        VSC_VK{ .Vsc = 0x6B, .Vk = X6B | KBDEXT }, // Speedracer: Launch App 1
        VSC_VK{ .Vsc = 0x6C, .Vk = X6C | KBDEXT }, // Speedracer: Launch Mail
        VSC_VK{ .Vsc = 0x6D, .Vk = X6D | KBDEXT }, // Speedracer: Launch Media Selector
        VSC_VK{ .Vsc = 0x1C, .Vk = X1C | KBDEXT }, // Numpad Enter
        VSC_VK{ .Vsc = 0x46, .Vk = X46 | KBDEXT }, // Break (Ctrl + Pause)

        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VSC_VK{ .Vsc = 0, .Vk = 0 },
    };

    var virtual_scan_codes_to_virtual_keys_e1 = [_]VSC_VK{
        VSC_VK{ .Vsc = 0x1D, .Vk = Y1D }, // Pause

        // End pointer list with 0
        // TODO: see if it must ends by 0 (sentinel)
        // ziglings 076_sentinels.zig
        VSC_VK{ .Vsc = 0, .Vk = 0 },
    };

    var kbd_tables = KBDTABLES{
        // Modifier keys
        .pCharModifiers = &modifiers,
        // Characters tables
        .pVkToWcharTable = &vk_to_wchar_table,
        // Diacritics
        .pDeadKey = &dead_keys,
        // Names of Keys
        .pKeyNames = &key_names,
        .pKeyNamesExt = &key_names_ext,
        .pKeyNamesDead = &key_names_dead,
        // Scan codes to Virtual Keys
        .pusVSCtoVK = &virtual_scan_codes_to_virtual_keys,
        .bMaxVSCtoVK = virtual_scan_codes_to_virtual_keys.len,
        .pVSCtoVK_E0 = &virtual_scan_codes_to_virtual_keys_e0,
        .pVSCtoVK_E1 = &virtual_scan_codes_to_virtual_keys_e1,
        // Locale-specific special processing
        .fLocaleFlags = MAKELONG(KLLF_ALTGR, KBD_VERSION),
        // Ligatures
        .nLgMax = 0,
        .cbLgEntry = 0,
        .pLigature = null,
        // Type and subtype. These are optional.
        // TODO: might be the cause of the crash, I don’t know how to make them optional
        .dwType = 0,
        .dwSubType = 0,
    };

    return &kbd_tables;
}

/// Describes all the tables that implement the keyboard layer.
///
/// When switching to a new layer, we get a new KBDTABLES structure: all key
/// processing tables are accessed indirectly through this structure.
const KBDTABLES = extern struct {
    /// Modifier keys
    pCharModifiers: *MODIFIERS,

    /// Characters
    pVkToWcharTable: [*]VK_TO_WCHAR_TABLE, // ptr to tbl of ptrs to tbl

    /// Diacritics
    pDeadKey: [*]DEADKEY,

    /// Names of Keys
    pKeyNames: [*]VSC_LPWSTR,
    pKeyNamesExt: [*]VSC_LPWSTR,
    pKeyNamesDead: [*]DEADKEY_LPWSTR,

    /// Scan codes to Virtual Keys
    pusVSCtoVK: [*]USHORT,
    bMaxVSCtoVK: BYTE,
    pVSCtoVK_E0: [*]VSC_VK, // Scancode has E0 prefix
    pVSCtoVK_E1: [*]VSC_VK, // Scancode has E1 prefix

    /// Locale-specific special processing
    fLocaleFlags: DWORD,

    /// Ligatures
    nLgMax: BYTE,
    cbLgEntry: BYTE,
    pLigature: ?*LIGATURE(1),

    /// Type and subtype. These are optional.
    dwType: DWORD, // Keyboard Type
    dwSubType: DWORD, // Keyboard SubType: may contain OemId
};

/// A table to map shift bits to enumerated shift states
///
/// Table attributes: Ordered table
///
/// Maps all possible shifter key combinations to an enumerated shift state.
/// The size of the table depends on the value of the highest order bit used
/// in aCharModifiers[*].ModBits
///
/// Special values for aModification[*]
///   SHFT_INVALID - no characters produced with this shift state.
/// TODO: LATER: (ianja) no SHFT_CTRL - control characters encoded in tables like others
///   SHFT_CTRL    - standard control character production (all keyboards must
///                  be able to produce CTRL-C == 0x0003 etc.)
///   Other        - enumerated shift state (not less than 0)
///
/// This table is indexed by the Modifier Bits to obtain an Modification Number.
///
///                        CONTROL MENU SHIFT
///
///    aModification[] = {
///        0,            //   0     0     0     = 000  <none>
///        1,            //   0     0     1     = 001  SHIFT
///        SHFT_INVALID, //   0     1     0     = 010  ALT
///        2,            //   0     1     1     = 011  SHIFT ALT
///        3,            //   1     0     0     = 100  CTRL
///        4,            //   1     0     1     = 101  SHIFT CTRL
///        5,            //   1     1     0     = 110  CTRL ALT
///        SHFT_INVALID  //   1     1     1     = 111  SHIFT CTRL ALT
///    };
const MODIFIERS = extern struct {
    /// Virtual Keys -> Mod bits
    pVkToBit: [*]VK_TO_BIT,

    /// max Modification bit combination value
    wMaxModBits: WORD,

    /// Mod bits -> Modification Number
    ModNumber: [*]BYTE,
};

/// Associate a Virtual Key with a Modifier bitmask.
const VK_TO_BIT = extern struct {
    /// The Virtual key (eg: VK_SHIFT, VK_RMENU, VK_CONTROL etc.)
    /// Special Values:
    ///     0        null terminator
    Vk: BYTE,

    /// A combination of KBDALT, KBDCTRL, KBDSHIFT and kbd-specific bits
    /// Any kbd-specific shift bits must be the lowest-order bits other
    /// than KBDSHIFT, KBDCTRL and KBDALT (0, 1 & 2)
    ///
    /// Those languages that use AltGr (VK_RMENU) to shift keys convert it to
    /// CTRL+ALT with the KBDSPECIAL bit in the ausVK[] entry for VK_RMENU
    /// and by having an entry in aVkToPfnOem[] to simulate the right Vk sequence.
    ModBits: BYTE,
};

/// Describe a table of VK_TO_WCHARS1
///
/// A keyboard may have several such tables: all keys with the same number of
///    shift-states are grouped together in one table.
const VK_TO_WCHAR_TABLE = extern struct {
    /// Points to the table.
    ///
    /// Special values:
    ///     NULL     - Terminates a VK_TO_WCHAR_TABLE[] list.
    pVkToWchars: ?*VK_TO_WCHARS(1),

    /// The number of shift-states supported by this table.
    /// (this is the number of elements in pVkToWchars[*].wch[])
    nModifications: BYTE,

    cbSize: BYTE,
};

/// Macro for VK to WCHAR with "n" shift states
///
/// Table element types (for various numbers of shift states), used
/// to facilitate static initializations of tables.
/// VK_TO_WCHARS(1) and *VK_TO_WCHARS(1) may be used as the generic type
fn VK_TO_WCHARS(comptime n: usize) type {
    return extern struct {
        VirtualKey: BYTE,
        Attributes: BYTE,
        wch: [n]WCHAR,
    };
}

/// Dead Key (diaresis) tables
const DEADKEY = extern struct {
    dwBoth: DWORD, // diacritic & char
    wchComposed: WCHAR,
    uFlags: USHORT,
};

fn DEADTRANS(ch: WORD, accent: WORD, comp: WCHAR, flags: USHORT) DEADKEY {
    return DEADKEY{
        .dwBoth = MAKELONG(ch, accent),
        .wchComposed = comp,
        .uFlags = flags,
    };
}

/// Concats bits of the two values, b being at the left and a at the right
fn MAKELONG(a: WORD, b: WORD) DWORD {
    // Not all casting makes sense in Zig (maybe because a and b already only has u16 length), I hope I rewrite it OK
    // return @as(c_long, @as(c_ushort, (@as(usize, a) & 0xffff)) | @as(c_ulong, @as(c_ushort, (@as(usize, b) & 0xffff))) << 16);
    return @as(DWORD, a) | (@as(DWORD, b) << 16);
}

/// Associate a Virtual Scancode with a Text string
///
/// Uses:
///   GetKeyNameText(), aKeyNames[]  Map virtual scancode to name of key
const VSC_LPWSTR = extern struct {
    vsc: BYTE,
    pwsz: ?[*:0]const WCHAR,
};

const DEADKEY_LPWSTR = ?[*]WCHAR;

fn _NE(v1: USHORT, v2: USHORT, v3: USHORT, v4: USHORT, v5: USHORT, v6: USHORT) USHORT {
    _ = v1;
    _ = v2;
    _ = v3;
    _ = v5;
    _ = v6;
    return v4; // KBD_TYPE
}

fn _EQ(v4: USHORT) USHORT {
    return v4; // KBD_TYPE
}

// Associate a Virtual Scancode with a Virtual Key
//  Vsc - Virtual Scancode
//  Vk  - Virtual Key | flags
// Used by VKFromVSC() for scancodes prefixed 0xE0 or 0xE1
const VSC_VK = extern struct {
    Vsc: BYTE,
    Vk: USHORT,
};

/// Macro for ligature with "n" characters
fn LIGATURE(comptime n: usize) type {
    return extern struct {
        VirtualKey: BYTE,
        ModificationNumber: WORD,
        wch: [n]WCHAR,
    };
}
